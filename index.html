
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Okabe&#39;s LAB</title>
    <meta name="author" content="Zihong Lin" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>OKABE&#39;S LAB</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;OKABE&#39;S LAB</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Okabe&#39;s LAB</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2025/05/10/vectordb/">
        <h2 class="post-title">Vector DB</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/5/10
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YpulM5HdSr8">[FIXME][EP09] 向量数据库和出海创业</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/">Locality Sensitive Hashing (LSH): The Illustrated Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://skyzh.github.io/write-you-a-vector-db/">Write You a Vector Database</a></li>
</ul>
<h3 id="常用的向量检索算法"><a href="#常用的向量检索算法" class="headerlink" title="常用的向量检索算法"></a>常用的向量检索算法</h3><ol>
<li><p>量化（以一定的模型性能换取查询效率），<a target="_blank" rel="noopener" href="https://github.com/gaoj0017/RaBitQ">RabitQ</a>。</p>
</li>
<li><p>Locality Sensitive Hashing (LSH)：传统的 hash 函数一般都希望减少碰撞，将一个 key 映射到尽可能分散的空间，而 <code>LSH</code> 则恰恰相反，通过将比较近的 <code>embedding</code> 映射到尽可能相同的 <code>bucket</code> 中，这样就能快速找到相邻的节点。</p>
<p> <img src="/2025/05/10/vectordb/lsh.png"></p>
</li>
<li><p>NSW(Navigate Small World)</p>
<p> <img src="/2025/05/10/vectordb/nsw.png"></p>
<p> 选择若干个 <code>entry</code>，然后维护一个有固定大小上限的队列，以类似 BFS 的方式，将距离目标向量最近的向量入队。需要多个 <code>entry</code> 的原因是，如果只采用一个，很容易陷入局部最优解。</p>
<p> 为了加速查询，我们会限制图中点之间的边的数量为 <code>max_m</code>。当我们插入一个节点的时候，其邻居节点的边可能会超过 <code>max_m</code>，所以我们需要重新计算这些节点的最近邻。</p>
</li>
<li><p>HNSW(Hierarchical Navigate Small World)</p>
<p> 将图以类似跳表的形式组织，但是无论是 NSW 还是 HNSW 都会涉及大量磁盘随机 I&#x2F;O，性能受限。</p>
</li>
<li><p>IVF(Inverted File)</p>
<p> <img src="/2025/05/10/vectordb/ivf.png"></p>
<p> 使用 <code>Kmeans</code> 将向量分为多个 <code>cluster</code>。并根据 <code>cluster</code> 的标识建立对向量的<code>倒排索引</code>。由于索引存储在一起，可以被顺序读写。</p>
<p> 在查询的时候，除了判断距离查询向量最近的质心对应的集群，还需要判断临近的集群。因为集群的质心可能距离查询向量比较远，但是边缘的点可能比较近。</p>
<p> <img src="/2025/05/10/vectordb/ivf_search.png"></p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/AI-Infra/" style="color: #ff7d73">AI Infra</a>
        </span>
        
    </div>
    <a href="/2025/05/10/vectordb/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/04/28/vllm/">
        <h2 class="post-title">vllm 学习笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/4/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/717581669">大模型推理加速与KV Cache（一）：什么是KV Cache</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=W83Zgbg8SkE&list=PLJj_urhaf2_qxpg8A5-6xoMvMLBKQMTX1&index=9">[FIXME][EP02][直播版] vllm源码讲解，分布式推理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=mWvqA_BNtsU&list=PLJj_urhaf2_qxpg8A5-6xoMvMLBKQMTX1">[FIXME][EP05][直播版] vllm从开源到部署，Prefix Caching和开源答疑</a></li>
<li><a target="_blank" rel="noopener" href="https://kevincheung2259.github.io/2025/03/29/CacheBlend/">CacheBlend-高效提高KVCache复用性的方法</a></li>
</ol>
<h3 id="Distributed-Inference"><a href="#Distributed-Inference" class="headerlink" title="Distributed Inference"></a>Distributed Inference</h3><p>具体的通信代码可以参考：<a target="_blank" rel="noopener" href="https://github.com/vllm-project/vllm/blob/main/vllm/model_executor/models/llama.py">vllm&#x2F;model_executor&#x2F;models&#x2F;llama.py</a></p>
<h4 id="分布式通信手段"><a href="#分布式通信手段" class="headerlink" title="分布式通信手段"></a>分布式通信手段</h4><ol>
<li>nvlink</li>
<li>InfiniBand</li>
<li>RDMA</li>
</ol>
<h4 id="并行方式"><a href="#并行方式" class="headerlink" title="并行方式"></a>并行方式</h4><ol>
<li><p>TP(Tensor Parallel)：</p>
<p> 将 tensor 拆分运算，然后通过 <code>all-reduce</code> &#x2F; <code>all-gather</code> 汇总。例如 LLM 的 <code>Decoder</code> 采用多头注意力（multihead-attention），假设有 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 576 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g></g></g></svg></mjx-container> 个头部，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></svg></mjx-container> 张卡，则可以每张卡 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.792ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1676 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path><path id="MJX-1-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-1-TEX-I-210E"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(576,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-1-TEX-N-2F"></use></g></g><g data-mml-node="mi" transform="translate(1076,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g></g></g></svg></mjx-container> 个头部并行计算。</p>
<p> <img src="/2025/04/28/vllm/multihead_attn.png"></p>
<pre><code class="python"># llama前向传播的代码
def forward(
    self,
    positions: torch.Tensor,
    hidden_states: torch.Tensor,
) -&gt; torch.Tensor:
    qkv, _ = self.qkv_proj(hidden_states)
    q, k, v = qkv.split([self.q_size, self.kv_size, self.kv_size], dim=-1)
    q, k = self.rotary_emb(positions, q, k)
    attn_output = self.attn(q, k, v)
    output, _ = self.o_proj(attn_output)
    return output
</code></pre>
</li>
<li><p>PP(Pipeline Parallel)：</p>
<p> 一个 request 由多个 node 流水线式地执行。可以提高吞吐，但是无法降低 <code>TTFT</code>。</p>
<p> 每个worker负责一个layers的子集</p>
<ul>
<li><code>vllm/model_executor/models/llama.py</code> 中 self.start_layer –&gt; self.end_layer   </li>
<li>在 worker 之间: <code>communicate IntermediateTensor</code></li>
<li><code>vllm/worker/model_runner.py</code>: 搜索 <code>get_pp_group()</code></li>
</ul>
</li>
<li><p>EP(Expert Parallel)：</p>
<p> 用于 MoE（Mixture of Expert）架构。在处理一个 request 的时候，只有一个很小的专家子集会被激活（通过门控控制）。router 会将 request 转发到相应的 expert 节点（MoE 的前置计算可能不是在相应的 expert 节点上进行的）。这里多个 expert 是并行的，同时计算不同的 batch。</p>
<ul>
<li>Shuffle (DeepEP communication kernel)</li>
<li>Forward</li>
<li>Shuffle back</li>
</ul>
</li>
</ol>
<p><img src="/2025/04/28/vllm/expert_parallel.png"></p>
<ol start="4">
<li><p>DP(Data Parallel)</p>
<p> 因为大型分布式生产环境中，EP &gt;&gt; TP（attention head 可能就十几个，而 experts 可能有几百个），这时候就需要 data parallel。</p>
<ul>
<li>TP * DP &#x3D;&#x3D; EP（通过请求并行的方式去拉满计算资源）</li>
<li>在实践中难以应用。</li>
<li>对请求进行padding避免造成死锁。</li>
</ul>
</li>
</ol>
<h3 id="Prefix-Caching"><a href="#Prefix-Caching" class="headerlink" title="Prefix Caching"></a>Prefix Caching</h3><p><img src="/2025/04/28/vllm/multi_turn_chat.png"></p>
<p>预备知识：</p>
<ol>
<li>LLM 的 <code>Prefill</code> 阶段：当用户输入一个 prompt（例如 “Hello, how are”），模型会一次性处理整个输入文本，计算所有输入 token 的隐藏状态。这个阶段通常是并行计算的，效率较高；LLM 的 <code>Decode</code> 阶段：模型从第一个生成的 token 开始，逐个预测后续的 token（例如 “you”、”today” 等）。每个新 token 的生成都依赖于前一个 token。</li>
<li>在多轮对话中，需要传递上下文，这些上下文总是共享一个前缀，如上图所示。显然，我们可以缓存这些前缀对应的 KV tensor，这也就是 <code>Prefix Caching</code>，缓存的对象便是 <code>K</code> 和 <code>V</code> tensor。</li>
<li><code>Prefix Caching</code> 只节省了 <code>Prefill</code> 阶段的耗时（也就是降低了 <code>TTFT</code> ，<code>Time To First Token</code>），并不能节省解码阶段的耗时（也就是 <code>TPOT</code> ，<code>Time Per Output Token</code>）。</li>
</ol>
<p><img src="/2025/04/28/vllm/prefix_caching.png"></p>
<p>vllm 中的 <code>Prefix Caching</code> 主要思路：</p>
<ol>
<li>将若干个 <code>tokens</code>（默认 16 个）组成一个 <code>block</code>，对于每个 <code>block</code>，计算其 hash 值并更新 <code>prefix hash</code>。</li>
<li>将 <code>prefix hash</code> -&gt; <code>kv cache</code> 的映射存储到 <code>kv store</code> 中（例如 redis，注意后者的 <code>kv</code> 指的是键值存储）。</li>
<li>若无法 <code>allocate</code> 缓存空间，以一定的策略（如 LFU，LRU）evict 一些缓存。</li>
</ol>
<p>伪代码：</p>
<pre><code class="python">prefix_hash = &quot;&quot;
for chunk in chunked_token:
    chunk_hash = hash(prefix_hash + chunk)
    prefix_hash = chunk_hash

for chunk_hash, chunk_kv in zip(...):
    kv_store.put(chunk_hash, chunk_kv)
</code></pre>
<h4 id="Prefix-Caching-的扩展——CacheBalend"><a href="#Prefix-Caching-的扩展——CacheBalend" class="headerlink" title="Prefix Caching 的扩展——CacheBalend"></a>Prefix Caching 的扩展——CacheBalend</h4><p><img src="/2025/04/28/vllm/cache_blend_1.png"></p>
<ul>
<li>Prefix Caching 只利用了前缀，缓存利用率有限；</li>
<li>Full KV Cache 使用所有的 Cache，会忽视 <code>cross attention</code>，产生低质量结果；</li>
<li>CacheBlend 通过重新计算一部分 KV，进行折中。</li>
</ul>
<p>以下是忽视 <code>cross attention</code> 的结果：</p>
<div style="text-align: center;">
  <img src="/2025/04/28/vllm/cache_blend_2.png" alt="Alt text" style="display: inline-block; margin-right: 10px;">
  <img src="/2025/04/28/vllm/cache_blend_3.png" alt="Alt text" style="display: inline-block;">
</div>

<h3 id="PD-分离"><a href="#PD-分离" class="headerlink" title="PD 分离"></a>PD 分离</h3><p>为什么需要 PD 分离？</p>
<blockquote>
<p>在大模型推理中，常用以下两项指标评估性能：<br>TTFT（Time-To-First-Token）：首 token 的生成时间，主要衡量 Prefill 阶段性能。<br>TPOT（Time-Per-Output-Token）：生成每个 token 的时间，主要衡量 Decode 阶段性能。<br>当 Prefill 和 Decode 在同一块 GPU 上运行时，由于两阶段的计算特性差异（Prefill 是计算密集型，而 Decode 是存储密集型），资源争抢会导致 TTFT 和 TPOT 之间的权衡。例如：</p>
<p>若优先处理 Prefill 阶段以降低 TTFT，Decode 阶段的性能（TPOT）可能下降。<br>若尽量提升 TPOT，则会增加 Prefill 请求的等待时间，导致 TTFT 上升。<br>PD 分离式架构的提出正是为了打破这一矛盾。通过将 Prefill 和 Decode 分离运行，可以针对不同阶段的特性独立优化资源分配，从而在降低首 token 延迟的同时提高整体吞吐量。</p>
</blockquote>
<p>Prefill 和 Decode 阶段分别受限于什么？</p>
<blockquote>
<p>Prefill 阶段：吞吐量随 batch size 增加逐渐趋于平稳。这是因为 Prefill 的计算受限特性（compute-bound），当 batch 中的总 token 数超过某个阈值时，计算资源成为瓶颈。</p>
<p>Decode 阶段：吞吐量随 batch size 增加显著提升。由于 Decode 阶段的存储受限特性（memory-bound），增大 batch size 可提高计算效率，从而显著增加吞吐量。</p>
</blockquote>
<p><img src="/2025/04/28/vllm/phase.png"></p>
<p>摘自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/9433793184">LLM推理优化 - Prefill-Decode分离式推理架构</a></p>
<p><img src="/2025/04/28/vllm/pd_disaggregation.png"></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/14689463165">Chunked Prefill</a></li>
<li>xP yD 问题，Prefill Instance 和 Decode Instance 的数量如何调整？</li>
<li>先 D 后 P 的模式：D node收到后先检查是否有 KVCache，没有的话再转给 P node去做，这个思路主要考虑的是 <code>TTFT</code>。</li>
</ol>
<h4 id="传递-KV-Cache"><a href="#传递-KV-Cache" class="headerlink" title="传递 KV Cache"></a>传递 KV Cache</h4><ul>
<li><p>两种模式：pooling 模式，P2P 模式，LMCache都支持上面两种模式，Mooncake(pooling)，NIXL(p2p)。</p>
</li>
<li><p>怎么从 vllm 提取（注入）KVCache</p>
<ul>
<li><code>connector API</code> in <code>vllm/worker/model_runner.py</code>。</li>
<li>在模型 <code>forward</code> 前：尝试接收 KVCache 并注入到到 vllm 的 pages memory 中。</li>
<li>在模型 <code>forward</code> 后，将 KVCache 从 pages memory 中并将它发送出去。</li>
</ul>
<p>  <img src="/2025/04/28/vllm/vllm_connector.png"></p>
</li>
<li><p><code>vllm/distributed/kv_transfer/kv_transfer_agent.py</code></p>
<pre><code class="python"># 本质上是根据 model input 计算出 KVCache 放在 page memory中的什么地方
def recv_kv_caches_and_hidden_states(
    self, model_executable: torch.nn.Module,
    model_input: &quot;ModelInputForGPUWithSamplingMetadata&quot;,
    kv_caches: List[torch.Tensor]
) -&gt; Tuple[Union[torch.Tensor, IntermediateTensors], bool,
        &quot;ModelInputForGPUWithSamplingMetadata&quot;]:
            
    return self.connector.recv_kv_caches_and_hidden_states(
        model_executable, model_input, kv_caches)
</code></pre>
<p>  可以先看 <code>vllm/distributed/kv_transfer/kv_connector/simple_connector.py</code>。</p>
</li>
</ul>
<h3 id="Speculative-Decoding"><a href="#Speculative-Decoding" class="headerlink" title="Speculative Decoding"></a>Speculative Decoding</h3><p>前文提到 Prefill 是 <code>gpu-bound</code>，计算密集型（把 request 的 tokens 全部输入 llm，生成第一个 token，并构建 KVCache）；而 Decode 是 <code>memory-bound</code>，依赖 Prefill 阶段生成的 KVCache，访存的时间往往大于计算的时间。那么有没有一种方法可以在不怎么增加 memory access 的前提下，提升计算的吞吐呢？<strong>有的，兄弟，有的</strong>，<code>Speculative Decoding</code>。</p>
<p><code>Speculative Decoding</code> 干了什么？其实就是去根据输入猜接下来的若干个 tokens 是什么，然后并行地进行验证。假如猜测 3 个 tokens，我们并行地验证这 3 个 tokens 是否正确的，由于是并行的，我们差不多只花费了原来只生成 1 个 token 的时间，最终获得了 3 个 tokens，也就是将吞吐提升了 3 倍，而访存只增加了（3 - 1）* token size。</p>
<p>那么如何猜呢？其实用一个古老的方法，<code>n-gram</code> 就行了。</p>
<blockquote>
<p>An n-gram is a sequence of n adjacent symbols in particular order. The symbols may be n adjacent letters (including punctuation marks and blanks), syllables, or rarely whole words found in a language dataset; or adjacent phonemes extracted from a speech-recording dataset, or adjacent base pairs extracted from a genome. They are collected from a text corpus or speech corpus.</p>
</blockquote>
<p><img src="/2025/04/28/vllm/ngram.png"></p>
<p>也就是说，我们根据一定的前缀，就能大致猜出后续的 token 搭配。<code>Speculative Decoding</code> 会根据输入构建 <code>ngram</code>，然后猜测后续的 tokens。</p>
<p><img src="/2025/04/28/vllm/speculative_decoding.png"></p>
<p>为什么这是有效的呢？下面几个 <code>workload</code> 就能说明这个问题：</p>
<ol>
<li>全文搜索，在用户给定的内容中寻找内容，或者给出一定答案。此处的回答一定是和用户内容强相关的，本质上会复读一部分；</li>
<li>代码生成场景，变量名、函数名等都很容易被 <code>ngram</code> 预测。</li>
</ol>
<h4 id="Tree-Verification"><a href="#Tree-Verification" class="headerlink" title="Tree Verification"></a>Tree Verification</h4><p><img src="/2025/04/28/vllm/tree_verification.png"></p>
<h4 id="Model-based（draft-model）Speculative-Decoding"><a href="#Model-based（draft-model）Speculative-Decoding" class="headerlink" title="Model-based（draft model）Speculative Decoding"></a>Model-based（draft model）Speculative Decoding</h4><ol>
<li><p>Parallel guessing（并行猜测）</p>
<ul>
<li>优点：快，在不知道第一个 token 情况下直接猜第二个。</li>
<li>缺点：在猜测第二个 token 的时候不知道第一个token是什么，容易胡言乱语</li>
</ul>
</li>
<li><p>Autoregression guessing（自回归猜测）</p>
<ul>
<li>优点：在猜测第二个 token 的时候知道第一个 token，准确率较高</li>
<li>缺点：慢</li>
</ul>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/LLM/" style="color: #ff7d73">LLM</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/vllm/" style="color: #00bcd4">vllm</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/AI-Infra/" style="color: #ff7d73">AI Infra</a>
        </span>
        
    </div>
    <a href="/2025/04/28/vllm/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/04/26/rocksdb/">
        <h2 class="post-title">RocksDB 学习笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Database/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Database
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/4/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            

	<div class="row">
    <embed src="/2025/04/26/rocksdb/rocksdb.pdf" width="100%" height="550" type="application/pdf">
	</div>




<h3 id="RocksDB-架构"><a href="#RocksDB-架构" class="headerlink" title="RocksDB 架构"></a>RocksDB 架构</h3><p><img src="/2025/04/26/rocksdb/arch.png"></p>
<p>先写入 <code>WAL</code>，再写入 <code>MemTable</code>。<code>MemTable</code> 达到一定的大小就会变为 <code>Immutable MemTable</code>，后台异步以 <code>SSTable</code> 的形式 flush 到磁盘中。</p>
<p><code>MemTable</code> 中还包含了一个 <code>Bloom Filter</code>，用于快速判断一个元素是否<strong>不存在</strong>。</p>
<h3 id="Column-Family"><a href="#Column-Family" class="headerlink" title="Column Family"></a>Column Family</h3><p>RocksDB 中列族是一个逻辑上的分组，列族之间使用不同的 LSM Tree，但是共享 WAL。</p>
<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/coguin/p/11405082.html">RocksDB Version管理概述</a></p>
<p><img src="/2025/04/26/rocksdb/version.png"></p>
<p><code>Version</code> 会指向不同的 SST，并且 <code>Version</code> 和 <code>SSTable</code> 都是以引用计数的方式维护，一旦引用计数变为 0，就会进行回收。</p>
<h3 id="Write-Batch"><a href="#Write-Batch" class="headerlink" title="Write Batch"></a>Write Batch</h3><p>参考文献：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://youjiali1995.github.io/rocksdb/write-batch/">RocksDB 源码分析 – Write Batch</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/643930273">RocksDB 剖析 | WriteThread 如何控制并发写入流程</a></li>
</ol>
<p>上面这篇文章讲的挺清楚的，RocksDB 默认是不开启并行写的，因为跳表结构并不适合并发写入，WAL 如果要并发写也需要一定同步机制维护其写入顺序。所以，RocksDB 采用的是分批写入的方式，以保证其吞吐量。<code>Write Batch Group</code> 会有一个 <code>leader</code>（当前的第一个 <code>writer</code>），然后后面的 <code>writer</code> 将成为 <code>follower</code>，构成一条双向链表（通过 <code>link_older</code>，<code>link_newer</code>）相连。这个 <code>group</code> 会有个大小上限，超过之后就会截断。截断后的新 <code>writer</code> 将会变为新的 <code>leader</code>，构成新的 <code>group</code>。</p>
<p>RocksDB 使用 <code>atomic::&lt;Writer *&gt;</code> 的形式组织链表，可以通过 <code>CAS</code> 以 <code>latch-free</code> 的方式添加 <code>writer</code>：</p>
<pre><code class="c++">Writer* writers = newest_writer-&gt;load(std::memory_order_relaxed);
while (true) &#123;
  w-&gt;link_older = writers;
  if (newest_writer-&gt;compare_exchange_weak(writers, w)) &#123;
    return (writers == nullptr);
  &#125;
&#125;
</code></pre>
<p>这边正好学习了一下 <code>std::atomic</code> 的用法，比起其他语言，c++ 的原子对象的 <code>load</code> 操作还可以选择不同的参数：</p>
<ol>
<li><code>std::memory_order_relaxed</code>：仅保证原子性，不强制内存顺序。</li>
<li><code>std::memory_order_acquire</code>：确保后续读操作不会重排到此操作之前。</li>
<li><code>std::memory_order_seq_cst</code>（默认）：顺序一致性，提供最强的内存屏障。</li>
</ol>
<p>尝试写了一个链表插入练习：</p>
<pre><code class="c++">#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;

struct ListNode &#123;
  int val;

  std::atomic&lt;ListNode *&gt; next;
&#125;;

void insertListNode(std::atomic&lt;ListNode *&gt; &amp;tail, ListNode **root, int val) &#123;
  ListNode *newNode = new ListNode;
  newNode-&gt;val = val;
  newNode-&gt;next = nullptr;
  ListNode *oldTail = tail.load(std::memory_order_relaxed);
  while (true) &#123;
    if (tail.compare_exchange_weak(oldTail, newNode)) &#123;
      break;
    &#125;
  &#125;
  if (oldTail == nullptr) &#123;
    *root = newNode;
  &#125; else &#123;
    oldTail-&gt;next = newNode;
  &#125;
&#125;

void printList(ListNode *root) &#123;
  if (root == nullptr) &#123;
    std::cout &lt;&lt; &quot;List is empty&quot; &lt;&lt; std::endl;
    return;
  &#125;
  ListNode *p = root;
  while (p) &#123;
    std::cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;;
    p = p-&gt;next.load(std::memory_order_relaxed);
  &#125;
  std::cout &lt;&lt; std::endl;
&#125;

int main() &#123;
  std::atomic&lt;ListNode *&gt; tail = nullptr;
  ListNode *root = nullptr;
  for (int i = 0; i &lt; 3; i++) &#123;
    std::thread t([&amp;, i]() &#123;
      while (1) &#123;
        insertListNode(tail, &amp;root, i);
        std::this_thread::sleep_for(std::chrono::milliseconds(300));
      &#125;
    &#125;);
    t.detach();
  &#125;

  while (1) &#123;
    printList(root);
    std::this_thread::sleep_for(std::chrono::milliseconds(300));
  &#125;
&#125;
</code></pre>
<p>一种 Lazy Initialize 的方式：</p>
<pre><code class="c++">std::optional&lt;std::mutex&gt; mtx;
mtx.emplace();
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Database/" style="color: #ff7d73">Database</a>
        </span>
        
    </div>
    <a href="/2025/04/26/rocksdb/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/04/20/foundation-db/">
        <h2 class="post-title">Foundation DB 学习笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/4/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            

	<div class="row">
    <embed src="/2025/04/20/foundation-db/paper.pdf" width="100%" height="550" type="application/pdf">
	</div>




<p>在线讲解：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1834y1Y7m7/?spm_id_from=333.1391.0.0&vd_source=f7e4c2acec163bdcd3e200e3623cc3e3">[Paper Reading] FoundationDB：开源分布式 KV 存储的内部实现原理</a></p>
<p>最近看 DeepSeek 的 3FS 的时候发现他们会用 FoundationDB 做 <code>chunk metadata</code> 的存储（3FS 有点像 GFS，也是以 chunk 作为存储单位）。正好不久之后要去阿里云开始一段存储相关的实习，学习一下相关知识。</p>
<p>FoundationDB 是一个分布式 KV 存储数据库，适用于读多写少的场景，支持 SSI（Serializable Snapshot Isolation）级别的事务。</p>
<h3 id="FoundationDB-如何实现-SSI"><a href="#FoundationDB-如何实现-SSI" class="headerlink" title="FoundationDB 如何实现 SSI"></a>FoundationDB 如何实现 SSI</h3><p>SSI 这一级别是通过 OCC + MVCC 实现的。</p>
<p>首先，让我们复习一下事务隔离级别，可以从这篇文章切入：<a target="_blank" rel="noopener" href="https://lotabout.me/2020/QQA-Isolation-Level-of-Database/">事务隔离级别备忘</a>。通过 MVCC 的快照，我们可以很容易地实现 Snapshot Isolation，虽然这解决了脏读和幻读的问题，但是无法解决两种问题（也就是上面链接中的 P4 和 A5B 问题）。</p>
<ul>
<li><p>P4 Lost Update</p>
<p>  <img src="/2025/04/20/foundation-db/lost_update.png"></p>
<p>  T2 修改 x 为 120，然而 T2 提交后被 T1 提交的修改覆盖，最终 x &#x3D; 130。对外界而言，x &#x3D; 120 这一修改不可见，被覆盖。</p>
</li>
<li><p>A5B Write Skew</p>
<p>  <img src="/2025/04/20/foundation-db/write_skew.png"></p>
<p>  x + y 应该满足约束 <code>x + y &lt;= 100</code>，由于 T1 和 T2 的 <code>write set</code> 没有相交，所以两个事务都能提交成功，然而约束已经被破坏。</p>
</li>
</ul>
<p>为了解决上述问题，FoundationDB 会维护一个 <code>read set</code>，如果 <code>read set</code> 中的某个 <code>key range</code> 对应的最新的一次 <code>commit version</code> 大于事务的 <code>read version</code>，就会 abort 当前事务。这种乐观的方式有若干好处：</p>
<ul>
<li>无需锁，高效；</li>
<li>读多写少，abort 是小概率事件。</li>
</ul>
<p>在 FoundationDB 中，<code>resolvers</code> 会保留最近一段时间（如 5 秒，MVCC window）内已提交的写入操作在内存中，这个时间范围就可以看作是一个 “窗口”。当一个新的事务进行冲突检测时，会将其读取的数据与这个窗口内的写入操作进行比较，以确定是否存在数据冲突。如果在这个窗口内，事务读取的数据被其他事务修改了，那么就会检测到冲突，该事务可能会被中止或重试。</p>
<p><img src="/2025/04/20/foundation-db/example.png"></p>
<h3 id="FoundationDB-的架构"><a href="#FoundationDB-的架构" class="headerlink" title="FoundationDB 的架构"></a>FoundationDB 的架构</h3><p><img src="/2025/04/20/foundation-db/architecture.png"></p>
<p>整个系统是自上而下启动的。FoundationDB 的控制面是通过 Paxos 算法选举出 Cluster Controller（即 leader），如下图所示。</p>
<p><img src="/2025/04/20/foundation-db/control_plane.png"></p>
<p>下图为数据面，主要由 TS + LS + SS 组成。</p>
<p><img src="/2025/04/20/foundation-db/data_plane.png"></p>
<h4 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h4><ul>
<li>Sequencer：<ul>
<li>负责获取 read&#x2F;commit version。</li>
</ul>
</li>
<li>Proxy：<ul>
<li>一个中介，负责获取 read version 和事务提交。</li>
</ul>
</li>
<li>Resolver：<ul>
<li>分布式地解决读写冲突。</li>
<li>多节点，按照 <code>key range</code> 分片（shard）。</li>
</ul>
</li>
</ul>
<h4 id="LS"><a href="#LS" class="headerlink" title="LS"></a>LS</h4><ul>
<li>按照 <code>key range</code> 分片（shard）。</li>
</ul>
<h4 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h4><ul>
<li>单机存储系统，从 LS 的 WAL 异步复制数据。</li>
<li>多版本数据只存储在内存中</li>
<li>5s 的 MVCC window（太长了会产生大量假阳性）</li>
</ul>
<h3 id="Log-System"><a href="#Log-System" class="headerlink" title="Log System"></a>Log System</h3><ul>
<li>Log Server 下面绑了若干 Storage Server。</li>
<li>按照 key range 映射到若干个 replica。</li>
<li>之所以需要向未被映射到的 Log Server 传递空消息，是因为 Log Server 是按照顺序执行的，不这样做会产生“空洞”。</li>
</ul>
<p><img src="/2025/04/20/foundation-db/log_system.png"></p>
<h3 id="Commit-Path"><a href="#Commit-Path" class="headerlink" title="Commit Path"></a>Commit Path</h3><ol>
<li>Client:<ol>
<li>Buffer Modifications</li>
<li>Send Read&#x2F;Write Set To Proxy</li>
</ol>
</li>
<li>Proxy: Get Commit Version from Sequencer</li>
<li>Proxy: Send User Data KeyRange To Resolvers</li>
<li>Resolver: Check RW Conflict</li>
<li>Proxy: Commit Phase When no Conflict<ol>
<li>Send Data to LS</li>
<li>Committed When All LS return Success</li>
<li>Send Commit Version to Sequencer for Read</li>
<li>Proxy return OK to Client</li>
</ol>
</li>
<li>SS pull WAL from LS</li>
</ol>
<p>Read: 1 roundtrip<br>Write: 4 roundtrip</p>
<h3 id="Recovery-Replication"><a href="#Recovery-Replication" class="headerlink" title="Recovery &amp;&amp; Replication"></a>Recovery &amp;&amp; Replication</h3><p><img src="/2025/04/20/foundation-db/recovery.png"></p>
<p>k &#x3D; f + 1</p>
<p>这里 k 表示需要复制的日志份数，f 表示系统可容忍的故障节点数。即需要复制的日志份数比可容忍的故障节点数多 1，通过这种方式来保证即使部分节点故障，日志信息也不会丢失，能维持系统的正常运行和数据一致性。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Database/" style="color: #03a9f4">Database</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Key-Value-Store/" style="color: #ffa2c4">Key-Value Store</a>
        </span>
        
    </div>
    <a href="/2025/04/20/foundation-db/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/03/24/sfinae/">
        <h2 class="post-title">SFINAE —— Substitution Failure Is Not An Error</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Language/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Language
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="IsConvertible"><a href="#IsConvertible" class="headerlink" title="IsConvertible"></a>IsConvertible</h3><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename FROM, typename TO&gt; struct IsConvetible &#123;
  // FROM should be converted to TO implicitly
  static void aux(TO);

  // Should use another typename F, otherwise it will cause an compilation error
  // immediately
  template &lt;typename F, typename = decltype(aux(std::declval&lt;F&gt;()))&gt;
  static std::true_type test(void *);

  // Will failed with: No viable conversion from &#39;double&#39; to &#39;std::string&#39;
  //   template &lt;typename = decltype(aux(std::declval&lt;FROM&gt;()))&gt;
  //   static std::true_type test(void *);

  // If the above function failed, it will fallback here
  template &lt;typename&gt; static std::false_type test(...);

  static constexpr bool value = decltype(test&lt;FROM&gt;(nullptr))::value;
&#125;;

int main() &#123;
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; IsConvetible&lt;double, std::string&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; IsConvetible&lt;double, int&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; IsConvetible&lt;const char *, std::string&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; IsConvetible&lt;const char[10], std::string&gt;::value &lt;&lt; std::endl;
  std::cout &lt;&lt; IsConvetible&lt;char[10], std::string&gt;::value &lt;&lt; std::endl;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>false
true
true
true
true
</code></pre>
<h3 id="IsDefaultConstructible"><a href="#IsDefaultConstructible" class="headerlink" title="IsDefaultConstructible"></a>IsDefaultConstructible</h3><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename T&gt; struct IsDefaultConstructibleHelper &#123;

  // Should use another typename U, otherwise it will cause an compilation error
  // immediately
  template &lt;typename U, typename = decltype(U())&gt;
  static std::true_type test(void *);

  // If the above function failed, it will fallback here.
  template &lt;typename&gt; static std::false_type test(...);

  static constexpr bool value = decltype(test&lt;T&gt;(nullptr))::value;
&#125;;

template &lt;typename T&gt;
constexpr bool IsDefaultConstructible = IsDefaultConstructibleHelper&lt;T&gt;::value;

class WithDefaultConstructor &#123;&#125;;

class WithoutDefaultConstructor &#123;
  WithoutDefaultConstructor() = delete;
&#125;;

int main() &#123;
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; IsDefaultConstructible&lt;int&gt; &lt;&lt; std::endl;
  std::cout &lt;&lt; IsDefaultConstructible&lt;WithDefaultConstructor&gt; &lt;&lt; std::endl;
  std::cout &lt;&lt; IsDefaultConstructible&lt;WithoutDefaultConstructor&gt; &lt;&lt; std::endl;
&#125;
</code></pre>
<p>输出：</p>
<pre><code>true
true
false
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #03a9f4">C++</a>
        </span>
        
    </div>
    <a href="/2025/03/24/sfinae/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/03/21/cpp-template2/">
        <h2 class="post-title">C++ Template 阅读笔记（2）</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Language/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Language
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>接上文，继续记录学习 C++ Template 这本书的心得。</p>
<h3 id="变参模板"><a href="#变参模板" class="headerlink" title="变参模板"></a>变参模板</h3><p>以下是一个例子：</p>
<pre><code class="c++">void print() &#123;&#125;

template &lt;typename T, typename... Types&gt;
void print(T firstArg, Types... args) &#123;
    std::cout &lt;&lt; firstArg &lt;&lt; std::endl;
    print(args...);
&#125;
</code></pre>
<p>上述的代码必须要定义 <code>print()</code> 这个重载函数，否则编译会不通过。因为 <code>Types... args</code> 的参数数量最后会变成 0，这样就找不到对应的函数了，也可以采用如下的版本。</p>
<pre><code class="c++">template &lt;typename T&gt;
void print(T arg) &#123;
    std::cout &lt;&lt; arg &lt;&lt; std::endl;
&#125;

template &lt;typename T, typename... Types&gt;
void print(T firstArg, Types... args) &#123;
    print(firstArg);
    print(args...);
&#125;
</code></pre>
<p>当传入的参数为 1 个的时候，会优先匹配第一个函数。</p>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><pre><code class="c++">template &lt;typename... T&gt; 
auto foldSum(T... args) &#123; return (... + args); &#125;
</code></pre>
<h3 id="变参下标（Variadic-Indices）"><a href="#变参下标（Variadic-Indices）" class="headerlink" title="变参下标（Variadic Indices）"></a>变参下标（Variadic Indices）</h3><pre><code class="c++">template &lt;typename T, typename... Idx&gt;
void printElements(const T &amp;v, Idx... idx) &#123;
  print(v[idx]...);
&#125;
const char *names[]&#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Peter&quot;&#125;;
// print &quot;Alice&quot; and &quot;Bob&quot;
printElements(names, 0, 1);

template &lt;size_t... Idx, typename C&gt; void printElements(const C &amp;v) &#123;
  print(v[Idx]...);
&#125;
const char *names[]&#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Peter&quot;&#125;;
// print &quot;Bob&quot; and &quot;Peter&quot;
printElements&lt;1, 2&gt;(names);
</code></pre>
<h3 id="模板成员变量"><a href="#模板成员变量" class="headerlink" title="模板成员变量"></a>模板成员变量</h3><pre><code class="c++">template&lt;typename T&gt;
class MyClass &#123;
public:
  static constexpr int size = sizeof(T);
&#125;;

template&lt;typename T&gt;
constexpr int Size = MyClass&lt;T&gt;::size;

std::cout &lt;&lt; Size&lt;char&gt; &lt;&lt; std::endl; // 1
std::cout &lt;&lt; Size&lt;double&gt; &lt;&lt; std::endl; // 8
</code></pre>
<p>各种 <code>type trait</code>，如 <code>std::is_const_v</code> 就是基于此。</p>
<h3 id="从-static-assert-到-std-enable-if-t-再到-concept"><a href="#从-static-assert-到-std-enable-if-t-再到-concept" class="headerlink" title="从 static_assert 到 std::enable_if_t 再到 concept"></a>从 static_assert 到 std::enable_if_t 再到 concept</h3><h4 id="static-assert"><a href="#static-assert" class="headerlink" title="static_assert"></a>static_assert</h4><pre><code class="c++">template &lt;typename T&gt; void foo(T t) &#123;
  static_assert(sizeof(T) &gt; 4,
                &quot;size of given type should be greater than 4 bytes&quot;);
  std::cout &lt;&lt; t &lt;&lt; std::endl;
&#125;
foo(1);
</code></pre>
<p>上述代码会报错：</p>
<blockquote>
<p>Static assertion failed due to requirement ‘sizeof(int) &gt; 4’: size of given type should be greater than 4 bytesclang(static_assert_requirement_failed)</p>
</blockquote>
<h4 id="std-enable-if-t"><a href="#std-enable-if-t" class="headerlink" title="std::enable_if_t"></a>std::enable_if_t</h4><pre><code class="c++">template &lt;typename T&gt; 
std::enable_if_t&lt;(sizeof(T) &gt; 4)&gt; foo(T t) &#123;
  std::cout &lt;&lt; t &lt;&lt; std::endl;
&#125;
</code></pre>
<p><code>std::enable_if_t</code> 等价于 <code>std::enable_if::type</code>。其中第一个模板类型是 <code>bool</code> 编译期常量，若为 <code>true</code>，则函数返回第二个模板类型（若没有第二个模板类型，则为 <code>void</code>），否则函数未定义。</p>
<p>上述代码会报未定义错误：</p>
<blockquote>
<p>No matching function for call to ‘foo’</p>
</blockquote>
<h4 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h4><pre><code class="c++">template &lt;typename T&gt;
  requires(sizeof(T) &gt; 4)
void foo(T t) &#123;
  std::cout &lt;&lt; t &lt;&lt; std::endl;
&#125;
</code></pre>
<p>类似的报错：</p>
<pre><code>No matching function for call to &#39;foo&#39;clang(ovl_no_viable_function_in_call)
main.cpp(18, 6): Candidate template ignored: constraints not satisfied [with T = int]
main.cpp(17, 12): Because &#39;sizeof(int) &gt; 4&#39; (4 &gt; 4) evaluated to false
</code></pre>
<h3 id="模板中按值传递-按引用传递"><a href="#模板中按值传递-按引用传递" class="headerlink" title="模板中按值传递 &amp; 按引用传递"></a>模板中按值传递 &amp; 按引用传递</h3><p>引用传递会保留类型的修饰，而值传递则会对类型进行退化。</p>
<pre><code class="c++">template&lt;typename T&gt;
void foo(T &amp;t) &#123;
  if constexpr(std::is_array_v&lt;T&gt;) &#123;
    std::cout &lt;&lt; &quot;is array&quot; &lt;&lt; std::endl;
  &#125;
  if constexpr(std::is_const_v&lt;T&gt;) &#123;
    std::cout &lt;&lt; &quot;is const&quot; &lt;&lt; std::endl;
  &#125;
&#125;

const char a[] = &quot;Hello, World&quot;;
foo(a);
// 输出
// is array
// is const
</code></pre>
<p>而将上述代码修改为值传递：</p>
<pre><code class="c++">template &lt;typename T&gt; void foo(T t) &#123;
  if constexpr (std::is_array_v&lt;T&gt;) &#123;
    std::cout &lt;&lt; &quot;is array&quot; &lt;&lt; std::endl;
  &#125;
  if constexpr (std::is_const_v&lt;T&gt;) &#123;
    std::cout &lt;&lt; &quot;is const&quot; &lt;&lt; std::endl;
  &#125;
&#125;
</code></pre>
<p>则不会产生任何输出，因为 <code>const char[13]</code> 被退化为了 <code>char *</code>，<br>既不是 <code>array</code> 也不是 <code>const</code>。</p>
<p>下面的函数有时候会产生问题：</p>
<pre><code class="c++">template&lt;typename T&gt;
T foo(T t) &#123;
  return t;
&#125;
</code></pre>
<p>虽然会对类型进行退化，但是仍然可以通过显式的方式将 <code>T</code> 声明为引用。</p>
<pre><code class="c++">int i;
foo&lt;int &amp;&gt;(i);
</code></pre>
<p>这样可能会导致垂悬引用（dangling reference），所以此处可以通过三种方式保证返回值是退化的。</p>
<pre><code class="c++">// 使用 auto 自动退化
template&lt;typename T&gt;
auto foo(T t) &#123;
  return t;
&#125;

// 使用 std::decay 显式退化
template&lt;typename T&gt;
std::decay_t&lt;T&gt; foo(T t) &#123;
  return t;
&#125;

// 去除引用
template&lt;typename T&gt;
std::remove_reference_t&lt;T&gt; foo(T t) &#123;
  return t;
&#125;
</code></pre>
<h3 id="std-is-convertible"><a href="#std-is-convertible" class="headerlink" title="std::is_convertible"></a>std::is_convertible</h3><p><code>std::is_convertible</code> 可以用于限制一个使用万能引用的构造函数的模板类型，例如：</p>
<pre><code class="c++">class MyClass &#123;
public:
  template &lt;typename T&gt;
  MyClass(T &amp;&amp;data)
    requires(std::is_convertible_v&lt;T, std::string&gt;)
      : data(data) &#123;&#125;

private:
  std::string data;
&#125;;

MyClass a(1); // error
</code></pre>
<p>报错信息：</p>
<pre><code>No matching constructor for initialization of &#39;MyClass&#39;clang(ovl_no_viable_function_in_init)
main.cpp(19, 7): Candidate constructor (the implicit copy constructor) not viable: no known conversion from &#39;int&#39; to &#39;const MyClass&#39; for 1st argument
main.cpp(19, 7): Candidate constructor (the implicit move constructor) not viable: no known conversion from &#39;int&#39; to &#39;MyClass&#39; for 1st argument
main.cpp(22, 3): Candidate template ignored: constraints not satisfied [with T = int]
main.cpp(23, 14): Because &#39;std::is_convertible_v&lt;int, std::string&gt;&#39; evaluated to false
</code></pre>
<h3 id="std-reference-wrapper"><a href="#std-reference-wrapper" class="headerlink" title="std::reference_wrapper"></a>std::reference_wrapper</h3><pre><code class="c++">std::string str = &quot;123&quot;;
auto r1 = std::ref(str); // std::reference_wrapper&lt;string&gt;
auto r2 = std::cref(str); // std::reference_wrapper&lt;const string&gt;
</code></pre>
<p><code>std::reference_wrapper</code> 相当于在引用外包了一层，这样就可以在保证性能的前提下进行值传递（有些模板采用值传递）。<code>std::reference_wrapper</code> 可以隐式地转换成包裹的引用本身。</p>
<pre><code class="c++">std::string &amp;s2 = r1;
const std::string &amp;s3 = r2;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">C++</a>
        </span>
        
    </div>
    <a href="/2025/03/21/cpp-template2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/03/20/interview-note/">
        <h2 class="post-title">面试笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Interview/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Interview
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>最近在面试阿里云文件存储 C++ 岗位，问了很多底层的问题，以前没有了解过或者印象不清，现在在此记录一番。</p>
<h3 id="std-shared-ptr-和-std-weak-ptr"><a href="#std-shared-ptr-和-std-weak-ptr" class="headerlink" title="std::shared_ptr 和 std::weak_ptr"></a>std::shared_ptr 和 std::weak_ptr</h3><p><img src="/2025/03/20/interview-note/image.png"></p>
<p><code>std::shared_ptr</code> 由指向的数据和控制块组成。控制块维护的是一些元数据，包括强引用计数和弱引用计数。</p>
<ul>
<li>当强引用计数变为 0 的时候，会释放指向的数据，但是保留控制块，因为可能存在若干 <code>std::weak_ptr</code> 指向该数据。可以通过 <code>std::weak_ptr::expired</code> 判断是否当前数据已过期（即强引用为 0，数据已经被释放）。</li>
<li>当弱引用计数变为 0 的时候，控制块也被释放，此时 <code>std::shared_ptr</code> 走向生命周期的终点。</li>
</ul>
<h3 id="如何遍历-std-tuple"><a href="#如何遍历-std-tuple" class="headerlink" title="如何遍历 std::tuple"></a>如何遍历 std::tuple</h3><h4 id="std-get"><a href="#std-get" class="headerlink" title="std::get"></a>std::get</h4><pre><code class="c++">auto t = std::make_tuple(1, &#39;123&#39;, 2.0);
std::cout &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; std::endl;
</code></pre>
<h4 id="std-apply"><a href="#std-apply" class="headerlink" title="std::apply"></a>std::apply</h4><pre><code class="c++">std::apply([](auto&amp;&amp;... args) &#123;
    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);
&#125;, t);
</code></pre>
<h4 id="std-index-sequence"><a href="#std-index-sequence" class="headerlink" title="std::index_sequence"></a>std::index_sequence</h4><pre><code class="c++">template &lt;typename T, size_t... Is&gt;
void printTuple(const T &amp;tuple, std::index_sequence&lt;Is...&gt;) &#123;
    ((std::cout &lt;&lt; std::get&lt;Is&gt;(tuple) &lt;&lt; &quot; &quot;), ...);
    std::cout &lt;&lt; std::endl;
&#125;

template &lt;typename ...Args&gt;
void printTuple(const std::tuple&lt;Args...&gt; &amp;t) &#123;
    printTuple(t, std::make_index_sequence&lt;sizeof...(Args)&gt;&#123;&#125;);
&#125;
printTuple(t);
</code></pre>
<p>顺便复习了一下可变参数模板：</p>
<pre><code class="c++">template &lt;typename ...Args&gt;
void print(Args... args) &#123;
    // 注意下面这个有无空格的两种写法
    // (std::cout &lt;&lt; ... &lt;&lt; args);
    ((std::cout &lt;&lt; args &lt;&lt; &quot; &quot;), ...);
    std::cout &lt;&lt; std::endl;
&#125;

template &lt;typename ...Args&gt;
auto sum(Args... args) &#123;
    return (... + args);
&#125;

template &lt;typename T, size_t... Is&gt;
void printElements(const T &amp;v, std::index_sequence&lt;Is...&gt;) &#123;
  print(v[Is]...);
&#125;

template &lt;typename T, typename... Is&gt;
void printElements(const T &amp;v, Is... idx) &#123;
  print(v[idx]...);
&#125;

template &lt;typename T, size_t... Is&gt;
void printTuple(const T &amp;tuple, std::index_sequence&lt;Is...&gt;) &#123;
    ((std::cout &lt;&lt; std::get&lt;Is&gt;(tuple) &lt;&lt; &quot; &quot;), ...);
    std::cout &lt;&lt; std::endl;
&#125;
</code></pre>
<h4 id="其他-points"><a href="#其他-points" class="headerlink" title="其他 points"></a>其他 points</h4><ul>
<li>使用数据分区、分片来提升性能；</li>
<li>top 指令的 nice 值应该就对应 MLPQ 里的优先级；</li>
<li>std::string_view；</li>
<li>为什么 MCS lock 使用 spin lock？<ul>
<li>基于 CAS，不涉及上下文切换</li>
<li>std::mutex 基于睡眠和唤醒</li>
</ul>
</li>
<li>WAL 和 多机分布式备份的优劣对比</li>
<li>std::shared_from_this</li>
<li>内外 const</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00a596">C++</a>
        </span>
        
    </div>
    <a href="/2025/03/20/interview-note/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/03/11/interview-algo/">
        <h2 class="post-title">面试常用算法复习</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Interview/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Interview
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/11
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="c++">void quicksort(vector&lt;int&gt; &amp;v, int l, int r) &#123;
  if (l &gt;= r) &#123;
    return;
  &#125;
  int target = v[l];
  int start = l;
  int end = r;
  while (true) &#123;
    while (l &lt; r &amp;&amp; v[r] &gt;= target) &#123;
      r--;
    &#125;
    while (l &lt; r &amp;&amp; v[l] &lt;= target) &#123;
      l++;
    &#125;
    if (l == r) &#123;
      break;
    &#125;
    swap(v[l], v[r]);
  &#125;
  swap(v[start], v[l]);
  quicksort(v, start, l - 1);
  quicksort(v, l + 1, end);
&#125;
</code></pre>
<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><pre><code class="c++">int fastPower(int x, int n) &#123;
  int base = x;
  int ans = 1;
  while (n) &#123;
    if (n &amp; 1) &#123;
      ans *= base;
    &#125;
    base *= base;
    n &gt;&gt;= 1;
  &#125;
  return ans;
&#125;

int fastPowerWithMod(int x, int n, int mod) &#123;
  int base = x;
  int ans = 1;
  while (n) &#123;
    if (n &amp; 1) &#123;
      ans = ((ans % mod) * (base % mod)) % mod;
    &#125;
    base = ((base % mod) * (base % mod)) % mod;
    n &gt;&gt;= 1;
  &#125;
  return ans;
&#125;
</code></pre>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><pre><code class="c++">int find(vector&lt;int&gt; &amp;fa, int x) &#123;
  return (fa[x] == x) ? x : (fa[x] = find(fa, fa[x]));
&#125;

void merge(vector&lt;int&gt; &amp;fa, int x, int y) &#123; 
    fa[find(fa, x)] = find(fa, y); 
&#125;
</code></pre>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><pre><code class="c++">#define left_child(x) ((x + 1) * 2 - 1)
#define right_child(x) ((x + 1) * 2)
#define parent(x) ((x + 1) / 2 - 1)

void makeHeap(vector&lt;int&gt; &amp;v) &#123;
  int n = v.size();
  for (int i = 0; i &lt; n; i++) &#123;
    int leftIdx = left_child(i);
    int rightIdx = right_child(i);
    if (leftIdx &gt;= n) &#123;
      break;
    &#125;
    if (leftIdx &lt; n &amp;&amp; v[leftIdx] &gt; v[i]) &#123;
      swap(v[leftIdx], v[i]);
    &#125;
    if (rightIdx &lt; n &amp;&amp; v[rightIdx] &gt; v[i]) &#123;
      swap(v[rightIdx], v[i]);
    &#125;
  &#125;
&#125;

void push(vector&lt;int&gt; &amp;v, int ele) &#123;
  v.push_back(ele);
  int idx = v.size() - 1;
  while (idx != 0) &#123;
    int parentIdx = parent(idx);
    if (v[parentIdx] &lt; v[idx]) &#123;
      swap(v[parentIdx], v[idx]);
      idx = parentIdx;
    &#125; else &#123;
      break;
    &#125;
  &#125;
&#125;

void siftDown(vector&lt;int&gt; &amp;v) &#123;
  int n = v.size();
  if (n == 0) &#123;
    return;
  &#125;
  int idx = 0;
  while (idx &lt; n) &#123;
    int leftIdx = left_child(idx);
    int rightIdx = right_child(idx);
    int maxIdx = -1;
    int maxV = v[idx];
    if (leftIdx &lt; n &amp;&amp; v[leftIdx] &gt; maxV) &#123;
      maxV = v[leftIdx];
      maxIdx = leftIdx;
    &#125;
    if (rightIdx &lt; n &amp;&amp; v[rightIdx] &gt; maxV) &#123;
      maxV = v[rightIdx];
      maxIdx = rightIdx;
    &#125;

    if (maxIdx == -1) &#123;
      break;
    &#125;
    swap(v[idx], v[maxIdx]);
    idx = maxIdx;
  &#125;
&#125;

int pop(vector&lt;int&gt; &amp;v) &#123;
  int n = v.size();
  if (n == 0) &#123;
    return 0;
  &#125;

  int ret = v[0];
  swap(v[n - 1], v[0]);
  v.pop_back();
  siftDown(v);
  return ret;
&#125;

void heapSort(vector&lt;int&gt; &amp;v) &#123;
  vector&lt;int&gt; h(v);
  makeHeap(h);
  int n = v.size();
  for (int i = 0; i &lt; n; i++) &#123;
    v[i] = pop(h);
  &#125;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #00bcd4">C++</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Algorithm/" style="color: #00a596">Algorithm</a>
        </span>
        
    </div>
    <a href="/2025/03/11/interview-algo/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2025/03/02/cpp-template/">
        <h2 class="post-title">C++ Template 阅读笔记（1）</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Language/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Language
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/3/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>最近在学习 <a target="_blank" rel="noopener" href="https://github.com/Walton1128/CPP-Templates-2nd--/blob/master/C%2B%2B%E6%A8%A1%E6%9D%BF_%E7%AC%AC%E4%BA%8C%E7%89%88.pdf">C++ Template</a> 这本书，补齐了一些模板元编程相关的信息，后续会持续更新。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="推断函数模板的返回值"><a href="#推断函数模板的返回值" class="headerlink" title="推断函数模板的返回值"></a>推断函数模板的返回值</h3><p>假设我们希望计算两个<strong>两个类型不相同</strong>的变量中的<strong>最大值</strong>（如 1u 和 2.0f），我们要如何定义函数模板？</p>
<pre><code class="c++">// since c++ 14
template &lt;typename T1, typename T2&gt; auto max(T1 x, T2 y) &#123;
  return x &gt; y ? x : y;
&#125;

// here x&#39;s type is float
auto x = ::max(1u, 2.0f);
</code></pre>
<p>从 c++ 14 开始，我们可以使用 <code>auto</code> 让编译器帮我们自动计算返回值的类型，然而在此之前，我们必须使用 <code>decltype</code> 或 <code>common_type</code> 这样的工具来告诉编译器，我们需要返回什么类型：</p>
<pre><code class="cpp">// c++ 11
template &lt;typename T1, typename T2&gt;
auto max(T1 x, T2 y) -&gt; decltype(x &gt; y ? x : y) &#123;
  return x &gt; y ? x : y;
&#125;

// equal to
template &lt;typename T1, typename T2&gt;
auto max(T1 x, T2 y) -&gt; decltype(true ? x : y) &#123;
  return x &gt; y ? x : y;
&#125;
</code></pre>
<p>然而，上述的代码可能面临一些严重的问题。在一些特殊场景下，返回值可能为引用，这时候需要使用类型萃取（type trait）std::decay<T>来将引用“退化”。</p>
<pre><code class="cpp">// c++ 11
#include &lt;type_traits&gt;
template &lt;typename T1, typename T2&gt;
auto max(T1 a, T2 b) -&gt; typename std::decay&lt;decltype(true ? a : b)&gt;::type &#123;
  return b &lt; a ? a : b;
&#125;

// since c++ 14, simplified
template &lt;typename T1, typename T2&gt;
auto max(T1 a, T2 b) -&gt; std::decay_t&lt;decltype(true ? a : b)&gt; &#123;
  return b &lt; a ? a : b;
&#125;
</code></pre>
<p>注意到 c++ 14 对 <code>typename std::decay&lt;decltype(true ? a : b)&gt;::type</code> 这样的写法进行了简化。</p>
<p>这边顺便回顾一下 <code>auto</code> 和 <code>decltype</code> 的区别：</p>
<p><code>auto</code> 在大部分场景下和模板类型 <code>T</code> 的行为是一致的，会对推导的类型进行退化（decay）。此处的退化是指：</p>
<ul>
<li>去除 <code>const</code>，<code>volatile</code> 等关键字；</li>
<li>去除引用</li>
<li>将数组退化成指针</li>
</ul>
<p><code>decltype</code> 则是老老实实地获取类型，不会进行退化操作。有一个比较有意思的特殊场景：</p>
<pre><code class="c++">// will return int &amp;
auto f(int a) -&gt; decltype((a)) &#123; return a; &#125;
</code></pre>
<p>虽然上述的用法是不正确的（返回了垂悬引用，dangling reference），但是能表明 <code>decltype</code> 会把 <code>()</code> 括起来的变量视作引用。</p>
<p>言归正传，之前的写法用 <code>decltype</code> 虽然能解决问题，但是未免太麻烦了点，我们可以用 <code>std::common_type_t&lt;T1, T2, ...&gt;</code> 来解决这个问题：</p>
<pre><code class="c++">// since c++ 14
template &lt;typename T1, typename T2&gt;
auto max(T1 a, T2 b) -&gt; std::common_type_t&lt;T1, T2&gt; &#123;
  return b &lt; a ? a : b;
&#125;
</code></pre>
<p>还有一种写法，实际上 c++ 在实例化模板时，只要能保证能推断出所有的类型即可，我们可以定义一个返回类型 <code>RT</code>:</p>
<pre><code class="c++">template &lt;typename RT, typename T1, typename T2&gt; 
RT max(T1 a, T2 b) &#123;
  return b &lt; a ? a : b;
&#125;
auto x = ::max&lt;float&gt;(1u, 2.0f);
</code></pre>
<p>这样只需要指定 <code>RT</code> 即可，因为 <code>T1</code> 和 <code>T2</code> 的类型对于编译器而言是已知的。但是下面的写法就会出错：</p>
<pre><code class="c++">template &lt;typename T1, typename T2, typename RT&gt;
RT max(T1 a, T2 b) &#123;
  return b &lt; a ? a : b;
&#125;
auto x = ::max&lt;unsigned int, float&gt;(1u, 2.0f);
</code></pre>
<p>报错信息为：</p>
<blockquote>
<p>Candidate template ignored: couldn’t infer template argument ‘RT’</p>
</blockquote>
<p>编译器无法自动推断 <code>RT</code> 的类型，除非使用上述的 <code>auto</code>。</p>
<p>c++ 还支持模板类型的默认值，比如常用的 <code>std::priority_queue</code> 实际上有 3 个模板类型。</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>c++ 支持使用基础的数值类型（double 除外）作为模板参数：</p>
<pre><code class="c++">template &lt;typename T, size_t MaxSize&gt; class Stack &#123;
  array&lt;T, MaxSize&gt; elements;
  Stack(T first) : elements(&#123;first&#125;) &#123;&#125;
&#125;;
</code></pre>
<p>虽然不支持直接使用字符串常量，但是可以通过定义一个变量来解决</p>
<pre><code class="c++">template &lt;char const *name&gt; class MyClass &#123;
  ...
&#125;;
MyClass&lt;&quot;hello&quot;&gt; x; // ERROR: string literal &quot;hello&quot; not allowed
extern char const s03[] = &quot;hi&quot;; // external linkage 
char const s11[] = &quot;hi&quot;; // internal linkage
int main() &#123;
  MyClass&lt;s03&gt; m03;               // OK (all versions)
  MyClass&lt;s11&gt; m11;               // OK since C++11
  static char const s17[] = &quot;hi&quot;; // no linkage
  MyClass&lt;s17&gt; m17;               // OK since C++17
&#125;
</code></pre>
<h2 id="推断指引（Deduction-Guides）"><a href="#推断指引（Deduction-Guides）" class="headerlink" title="推断指引（Deduction Guides）"></a>推断指引（Deduction Guides）</h2><pre><code class="c++">template &lt;typename T&gt; class Stack &#123;
  vector&lt;T&gt; elements;

public:
  Stack() = default;
  Stack(T first) : elements(&#123;first&#125;) &#123;&#125;
&#125;;

Stack(char const *)-&gt;Stack&lt;std::string&gt;;

Stack s(&quot;123&quot;);
</code></pre>
<p>如果没有 <code>Stack(char const *)-&gt;Stack&lt;std::string&gt;;</code>，s 将被推导为 <code>Stack&lt;const char *&gt;</code>。</p>
<h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><pre><code class="c++">template &lt;typename T&gt; struct AccumulationTraits;
template &lt;&gt; struct AccumulationTraits&lt;int&gt; &#123;
  using AccT = int;
  static AccT constexpr zero = 0;
&#125;;

template &lt;&gt; struct AccumulationTraits&lt;string&gt; &#123;
  using AccT = string;
  // support since c++ 17
  inline static AccT const zero = &quot;&quot;;
&#125;;

template &lt;typename T&gt; auto accum(T begin, T end) &#123;
  using AccT = AccumulationTraits&lt;T&gt;::AccT;
  AccT total = AccumulationTraits&lt;T&gt;::zero;

  for (T i = begin; i &lt;= end; i++) &#123;
    total += i;
  &#125;
  return total;
&#125;

int main(int, char **) &#123;
  auto total = accum(1, 100);
  cout &lt;&lt; total &lt;&lt; endl;
&#125;
</code></pre>
<pre><code class="c++">template &lt;typename T&gt;
concept Addable = requires(T a, T b) &#123;
                    &#123; a + b &#125; -&gt; std::same_as&lt;T&gt;;
                  &#125;;

template &lt;typename T&gt;
  requires Addable&lt;T&gt; &amp;&amp; std::is_arithmetic_v&lt;T&gt;
T accum(T begin, T end) &#123;
  T total&#123;&#125;;
  for (T i = begin; i &lt;= end; i++) &#123;
    total += i;
  &#125;
  return total;
&#125;
</code></pre>
<p>此处也可以把 <code>typename</code> 替换成 <code>Addable</code> 之类的 <code>concept</code>。和 <code>rust</code> 的 <code>trait</code> 语法非常类似。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/C/" style="color: #ff7d73">C++</a>
        </span>
        
    </div>
    <a href="/2025/03/02/cpp-template/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/07/09/kmesh-env/">
        <h2 class="post-title">Kmesh 环境配置</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Cloud-Native/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Cloud Native
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li><p>下载 <a target="_blank" rel="noopener" href="https://repo.openeuler.org/openEuler-23.03/">openEuler 23.03</a></p>
</li>
<li><p>安装 kernel headers:</p>
<pre><code class="shell">yum install kernel-headers
</code></pre>
</li>
<li><p>安装 docker：</p>
<p>  参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2383890">https://cloud.tencent.com/developer/article/2383890</a></p>
<pre><code class="shell">curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo
sed -i &#39;s#https://download.docker.com#https://mirrors.tuna.tsinghua.edu.cn/docker-ce#&#39; /etc/yum.repos.d/docker-ce.repo
sed -i &#39;s#$releasever#7#g&#39; /etc/yum.repos.d/docker-ce.repo
yum install docker-ce-24.0.7
</code></pre>
</li>
<li><p>修改 docker proxy:</p>
<p>  修改 <code>/etc/docker/daemon.json</code> 为如下格式：</p>
<pre><code class="json">&#123;
    &quot;proxies&quot;: &#123;
        &quot;http-proxy&quot;: &quot;http://ip:7890&quot;,
        &quot;https-proxy&quot;: &quot;http://ip:7890&quot;,
        &quot;no-proxy&quot;: &quot;127.0.0.1,localhost&quot;
    &#125;
&#125;
</code></pre>
<p>  重启 docker:</p>
<pre><code class="shell">systemctl restart docker
systemctl status docker
</code></pre>
</li>
<li><p>安装 kind </p>
<pre><code class="shell">wget https://github.com/kubernetes-sigs/kind/releases/download/v0.23.0/kind-linux-amd64
chmod +x kind-linux-amd64
mv kind-linux-amd64 /usr/bin/kind
</code></pre>
</li>
<li><p>安装 istioctl</p>
<pre><code class="shell">curl -L https://istio.io/downloadIstio | sh -
cd istio-1.22.2/bin
chmod +x istioctl
mv istioctl /usr/bin/
</code></pre>
</li>
<li><p>创建 ambient 模式集群</p>
<pre><code class="shell">kind create cluster --image=kindest/node:v1.23.17 --config=- &lt;&lt;EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
name: ambient
nodes:
- role: control-plane
- role: worker
- role: worker
EOF

istioctl install --set profile=ambient --skip-confirmation
</code></pre>
</li>
<li><p>安装 go</p>
<p>  <a target="_blank" rel="noopener" href="https://golang.google.cn/doc/install">https://golang.google.cn/doc/install</a></p>
</li>
<li><p>安装 kubectl</p>
<p>  <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/zh-cn/docs/tasks/tools/install-kubectl-linux/</a></p>
</li>
<li><p>安装 kmesh</p>
<p>  参考 <a target="_blank" rel="noopener" href="https://kmesh.net/en/docs/setup/quickstart/">https://kmesh.net/en/docs/setup/quickstart/</a> 即可。</p>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://istio.io/latest/docs/ambient/getting-started/">https://istio.io/latest/docs/ambient/getting-started/</a></li>
<li><a target="_blank" rel="noopener" href="https://istio.io/latest/zh/blog/2022/get-started-ambient/">https://istio.io/latest/zh/blog/2022/get-started-ambient/</a></li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Istio/" style="color: #ff7d73">Istio</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Kmesh/" style="color: #00bcd4">Kmesh</a>
        </span>
        
    </div>
    <a href="/2024/07/09/kmesh-env/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    <a class="page-num" href="/page/2">2</a>
    
    
    <a class="page-num" href="/page/3">3</a>
    
    
    <span class="page-omit">...</span>
    <a class="page-num" href="/page/4">4</a>
    
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">Zihong Lin</div>
        <div class="description">
            <p>What I can’t create, I don’t understand.</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 Okabe&#39;s LAB
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zihong Lin
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
