
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Okabe&#39;s LAB</title>
    <meta name="author" content="Zihong Lin" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://cdn.staticfile.org" />
<script src="https://cdn.staticfile.org/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.loli.net" />
<link rel="preconnect" href="https://gstatic.loli.net" crossorigin />
<link rel="stylesheet" href="https://fonts.loli.net/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.1.1"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>OKABE&#39;S LAB</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;OKABE&#39;S LAB</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Okabe&#39;s LAB</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap" true ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/02/08/memorize/">
        <h2 class="post-title">纪念一次成功的开源贡献</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Life/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Life
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><a target="_blank" rel="noopener" href="https://github.com/qdrant/qdrant/pull/3549">https://github.com/qdrant/qdrant/pull/3549</a><br><img src="/2024/02/08/memorize/image.png"><br>没想到还能赚美刀～</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/02/08/memorize/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/02/05/rust-note-1/">
        <h2 class="post-title">Rust 笔记（1）—— 关于 tokio spawn</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Language/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Language
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/2/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>假如说有这样一个异步函数 <code>async_func</code>，如果在同步函数中不用 <code>await</code> 调用它，它是不会被执行的，除非使用 <code>tokio::task::spawn</code> 函数开启一个异步任务。该函数接受一个 Future 参数，会返回一个 <code>tokio::task::JoinHandle&lt;T&gt;</code>，其中范型 <code>T</code> 是异步任务的返回值。</p>
<blockquote>
<p>JoinHandle类型可以通过await来等待异步任务的完成，也可以通过abort()来中断异步任务，异步任务被中断后返回JoinError类型。</p>
</blockquote>
<p>举个例子：</p>
<pre><code class="rust">async fn async_func() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; &#123;
    ...
    Ok(())
&#125;

fn sync_func() &#123;
    // handle 的类型为 JoinHandle&lt;Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;&gt;
    let handle = spawn(async_func());
    // 中断
    handle.abort();
    // 等待完成（需要在异步函数中）
    // handle.await
&#125;
</code></pre>
<p>可以使用 <code>tokio::join!</code> 宏来等待多个 <code>JoinHandle</code> 执行完成。</p>
<p>这里的 <code>spawn</code> 如果不等待的话，就会自己独立执行，所以会要求引用数据的生命周期是 <code>&#39;static</code>，也就是活到程序结束（因为异步任务也可能执行到程序结束）。这就会带来一些编码上的困难，例如下面的例子：</p>
<pre><code class="rust">struct Manager;
impl Manager &#123;
    async fn do_something_async(&amp;self) &#123;&#125;

    fn start(&amp;self) &#123;
        spawn(self.do_something_async());
    &#125;
&#125;
</code></pre>
<p>上述的代码会报错：</p>
<pre><code>error[E0521]: borrowed data escapes outside of method
  --&gt; src/test.rs:22:15
   |
21 |     fn start(&amp;self) &#123;
   |              -----
   |              |
   |              `self` is a reference that is only valid in the method body
   |              let&#39;s call the lifetime of this reference `&#39;1`
22 |         spawn(self.do_something_async());
   |               ^^^^^^^^^^^^^^^^^^^^^^^^^
   |               |
   |               `self` escapes the method body here
   |               argument requires that `&#39;1` must outlive `&#39;static`
</code></pre>
<p><code>spawn</code> 要求 <code>&amp;self</code> 的生命周期必须是 <code>&#39;static</code>，我查阅了一些资料，从 Rust 论坛中看到了相关问题。解决方案是使用 <code>Arc</code> 或 <code>Arc/Mutex</code>（如果有可变引用）。</p>
<pre><code class="rust">struct Manager &#123;
    inner: Arc&lt;ManagerInner&gt;,
&#125;
struct ManagerInner;
impl ManagerInner &#123;
    async fn do_something_async(&amp;self) &#123;&#125;
&#125;

impl Manager &#123;
    fn start(&amp;self) &#123;
        let inner_cloned = self.inner.clone();
        spawn(async move &#123;
            inner_cloned.do_something_async().await;
        &#125;);
    &#125;
&#125;
</code></pre>
<p>通过这一层包裹，就不报错了。<code>Arc</code> 保证了引用可以活到程序结束（只要还有引用，就不会被回收），即使 <code>Manager</code> 被回收，只要异步任务还在进行，<code>ManagerInner</code> 还是存在一份。这边必须使用 <code>move</code> 告诉编译器移动 <code>inner_cloned</code> 而不是捕获它的引用（捕获引用是默认行为）。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>理解tokio核心(2): task：<a target="_blank" rel="noopener" href="https://rust-book.junmajinlong.com/ch100/02_understand_tokio_task.html">https://rust-book.junmajinlong.com/ch100/02_understand_tokio_task.html</a></li>
<li>Rust 论坛 How to use self while spawning a thread from method：<a target="_blank" rel="noopener" href="https://users.rust-lang.org/t/how-to-use-self-while-spawning-a-thread-from-method/8282">https://users.rust-lang.org/t/how-to-use-self-while-spawning-a-thread-from-method/8282</a></li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Rust/" style="color: #ffa2c4">Rust</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Tokio/" style="color: #03a9f4">Tokio</a>
        </span>
        
    </div>
    <a href="/2024/02/05/rust-note-1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/04/06/k8s-note-2/">
        <h2 class="post-title">Kubernetes 笔记（2）—— 记一次 Kubernetes 小练习</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Cloud-Native/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Cloud Native
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h1><p>该 lab 基于 Minikube，用于练习 K8s 最基本的 Api Object，如 ConfigMap，Secret，Pod，Service 等等。</p>
<h2 id="使用-Secret-指定-Mysql-密码"><a href="#使用-Secret-指定-Mysql-密码" class="headerlink" title="使用 Secret 指定 Mysql 密码"></a>使用 Secret 指定 Mysql 密码</h2><pre><code class="shell">kubectl apply -f lab1/mysql_secret.yml
</code></pre>
<p>该 YAML 文件中制定了数据库的密码。</p>
<pre><code class="yaml">stringData:
  db_password: &#39;123456&#39;
</code></pre>
<p>在创建 Mysql 对应的 Pod 的时候，可以使用这个 Secret 来指定 Mysql 的密码。<br>如下所示，使用环境变量指定 Mysql root 用户的密码，这个密码源自 Secret 中定义的 db_password</p>
<pre><code class="yaml">env:
    - name: MYSQL_ROOT_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mysql-secret
        key: db_password
</code></pre>
<p>创建 Mysql 对应的 Pod：</p>
<pre><code class="shell">kubectl apply -f lab1/mysql_pod.yml
</code></pre>
<p>验证 Mysql 正确指定了密码：</p>
<pre><code class="shell">kubectl exec -it mysql -- mysql -uroot -p123456
</code></pre>
<p>有关 Secret 的更多声明方式：<a target="_blank" rel="noopener" href="https://github.com/omerbsezer/Fast-Kubernetes/blob/main/K8s-Secret.md">https://github.com/omerbsezer/Fast-Kubernetes/blob/main/K8s-Secret.md</a></p>
<h2 id="创建-Mysql-对应的-Service"><a href="#创建-Mysql-对应的-Service" class="headerlink" title="创建 Mysql 对应的 Service"></a>创建 Mysql 对应的 Service</h2><pre><code class="shell">kubectl apply -f lab1/mysql_service.yml
</code></pre>
<p>该 YAML 文件中指定了选中的 Pod 以及端口。使用 NodePort 的方式会在每个 Node 的 ip 上暴露一个端口，<br>来访问对应的 Service 服务。<br>同时，可以随机暴露出一个端口外部访问的端口（默认值：30000-32767）。</p>
<p>一般而言，对于数据库这种服务，应该使用 ClusterIp，只在集群内部使用，这边为了测试服务连接，故暴露给外部。</p>
<pre><code class="yaml">spec:
  type: NodePort
  selector:
    app: db
  ports:
    - protocol: TCP
      port: 3306
      targetPort: 3306
</code></pre>
<p>这里的 selector 对应了 <code>lab1/mysql_pod.yml</code> 中指定的 labels：</p>
<pre><code class="yaml">labels:
  app: db
</code></pre>
<p>创建该 Service：</p>
<pre><code class="shell">kubectl apply -f lab1/mysql_service.yml
</code></pre>
<p>查看当前的 Service：</p>
<pre><code class="shell">$ kubectl get svc
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes      ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          25m
mysql-service   NodePort    10.108.143.219   &lt;none&gt;        3306:30160/TCP   14s
</code></pre>
<p>其中 <em>3306</em> 是集群内的端口，pod 可以通过这个端口进行访问：<code>mysql-service:3306</code>（通过 service 名直接访问该服务）。30160 是对外可见的端口，在集群外部可以通过 <code>nodeIp:30160</code> 访问。</p>
<p>可以看到集群暴露了 30160 的端口给外部使用，不过我们使用的是 Minikube，所有的 k8s 组件都跑在 Docker 容器里，<br>所以我们必须要用 tunnel 才能真正访问该 Service：</p>
<pre><code class="shell">minikube service --url mysql-service
</code></pre>
<p>该指令会开启一个 tunnel，并且提供一个可访问的 url，相当于让我们能够去访问 30160 端口，并最终访问到内部的 Service。</p>
<pre><code class="shell">$ minikube service --url mysql-service
http://127.0.0.1:51634
❗  Because you are using a Docker driver on windows, the terminal needs to be open to run it.
</code></pre>
<p>可以用一些数据库工具来验证是否能够连接：</p>
<p><img src="/2023/04/06/k8s-note-2/image.png"></p>
<h2 id="使用-ConfigMap-配置数据库信息"><a href="#使用-ConfigMap-配置数据库信息" class="headerlink" title="使用 ConfigMap 配置数据库信息"></a>使用 ConfigMap 配置数据库信息</h2><p>ConfigMap 和 Secret 基本一致，只不过后者用于存储密文信息。但是注意，单纯使用 Secret 仍然存在风险，<br>因为其使用的 base64 并不能保证安全性，应该配合 k8s 提供的 RBAC 机制使用。</p>
<p>这边指定了使用的 mysql-server。</p>
<pre><code class="yaml">data:
  db_server: &quot;mysql-service&quot;
</code></pre>
<p>添加该 ConfigMap：</p>
<pre><code class="shell">kubectl apply -f lab1/mysql_configmap.yml
</code></pre>
<p>我们启动一个测试 Pod 查看效果：</p>
<pre><code class="shell">kubectl apply -f lab1/test_pod.yml
</code></pre>
<p>在该 Pod 内部查看环境变量是否正确：</p>
<pre><code class="shell">kubectl exec -it test -- bin/sh
echo $MYSQL_SERVER
echo $MYSQL_ROOT_PASSWORD
</code></pre>
<p>应该得到如下的输出：</p>
<pre><code class="shell">$ kubectl exec -it test -- bin/sh
/ # echo $MYSQL_SERVER
mysql-service
/ # echo $MYSQL_ROOT_PASSWORD
123456
</code></pre>
<p>注意，k8s 里的 Service 是 ping 不通的，以下摘自：<a target="_blank" rel="noopener" href="https://kuboard.cn/learning/faq/ping-service.html">https://kuboard.cn/learning/faq/ping-service.html</a></p>
<blockquote>
<p>因为 Kubernetes 只是为 Service 生成了一个虚拟 IP 地址，实现的方式有：</p>
<ul>
<li>User space 代理模式</li>
<li>Iptables 代理模式</li>
<li>IPVS 代理模式</li>
</ul>
<p>不管是哪种代理模式，Kubernetes Service 的 IP 背后都没有任何实体可以响应「ICMP」，全称为 Internet 控制报文协议（Internet Control Message Protocol）。</p>
</blockquote>
<p>我们可以在 test pod 里面安装 telnet 指令，查看连接情况：</p>
<pre><code class="shell">apk update
apk add busybox-extras
</code></pre>
<p><strong>注意，可以直接用 Service 的名字，依靠 DNS 访问服务，但是这里只是 hostname，还需要指定端口号</strong></p>
<pre><code class="shell">telnet &quot;$MYSQL_SERVER:3306&quot;
</code></pre>
<h2 id="修改-ConfigMap-之后更新-Pod"><a href="#修改-ConfigMap-之后更新-Pod" class="headerlink" title="修改 ConfigMap 之后更新 Pod"></a>修改 ConfigMap 之后更新 Pod</h2><p>我们可以通过以下方式对 Api Object 的配置进行修改，以之前的 ConfigMap 为例：</p>
<pre><code class="shell">kubectl edit configmap mysql-config
</code></pre>
<p>这会启动一个文本编辑器让你进行修改。这里我们把 <code>db_server</code> 修改成了 <code>dummy</code>。<br>我们再次进入 test Pod，看看环境变量是否改变：</p>
<pre><code class="shell">kubectl exec -it test -- bin/sh
echo $MYSQL_SERVER
</code></pre>
<p>输出依旧是之前的 <code>mysql-service</code>，也就是说修改 ConfigMap 不会导致引用它的 Pod 的自动更新。我们需要一些其他手段让 Pod 在 ConfigMap 更新的时候也进行更新。</p>
<h3 id="使用-Deployment"><a href="#使用-Deployment" class="headerlink" title="使用 Deployment"></a>使用 Deployment</h3><p>Deployment 可以支持滚动升级，当我们的 ConfigMap 修改的时候，可以认为是一次版本变动，我们可以通过 Deployment 更新对应的 Pod。 </p>
<p>我们先删除之前的 test Pod，</p>
<pre><code class="shell">kubectl delete -f lab1/test_pod.yml
</code></pre>
<p>接下来我们要用 Deployment 来管理这个 Pod。Deployment 的 Template 对应了 Pod 的 Spec。</p>
<p>创建对应的 Deployment：</p>
<pre><code class="shell">kubectl apply -f lab1/test_deployment.yml
</code></pre>
<p>查看生成的 Pod(s)：</p>
<pre><code class="shell">$ kubectl get pods
NAME                   READY   STATUS    RESTARTS   AGE
mysql                  1/1     Running   0          102m
test-7775f744b-c7sgs   1/1     Running   0          25s
</code></pre>
<p>进入该 Pod 查看环境变量：</p>
<pre><code class="shell">kubectl exec -it test-7775f744b-c7sgs -- bin/sh
echo $MYSQL_SERVER
</code></pre>
<p>输出为 <code>dummy</code>，现在我们把 configmap 修改为之前的版本。</p>
<p>然后，我们使用如下方法（ <a target="_blank" rel="noopener" href="https://www.qttc.net/504-how-update-latest-configmap-in-pods.html">https://www.qttc.net/504-how-update-latest-configmap-in-pods.html</a> ）更新 Pod：</p>
<pre><code class="shell">kubectl rollout restart deploy/test
</code></pre>
<p>我们可以在另外两个终端，通过：</p>
<pre><code class="shell">kubectl get rs -w
</code></pre>
<p>以及 </p>
<pre><code class="shell">kubectl get pods -w
</code></pre>
<p>查看发生的变化：</p>
<pre><code>$ kubectl get rs -w
NAME             DESIRED   CURRENT   READY   AGE
test-7775f744b   1         1         1       9m32s
test-595fb97b87   1         0         0       0s
test-595fb97b87   1         0         0       0s
test-595fb97b87   1         1         0       0s
test-595fb97b87   1         1         1       5s
test-7775f744b    0         1         1       9m58s
test-7775f744b    0         1         1       9m58s
test-7775f744b    0         0         0       9m58s
</code></pre>
<pre><code>$ kubectl get pods -w
NAME                   READY   STATUS    RESTARTS   AGE  
mysql                  1/1     Running   0          112m 
test-7775f744b-c7sgs   1/1     Running   0          9m46s
test-595fb97b87-mqb2m   0/1     Pending   0          0s
test-595fb97b87-mqb2m   0/1     Pending   0          0s
test-595fb97b87-mqb2m   0/1     ContainerCreating   0          0s
test-595fb97b87-mqb2m   1/1     Running             0          5s
test-7775f744b-c7sgs    1/1     Terminating         0          9m58s
test-7775f744b-c7sgs    0/1     Terminating         0          10m
test-7775f744b-c7sgs    0/1     Terminating         0          10m
test-7775f744b-c7sgs    0/1     Terminating         0          10m
</code></pre>
<p>可以通过如下指令查看 Deployment 的历史版本：</p>
<pre><code class="shell">kubectl rollout history deploy/test
</code></pre>
<p>我们再次进入 test Pod，查看环境变量：</p>
<pre><code class="shell">kubectl exec -it test-595fb97b87-mqb2m -- bin/sh
echo $MYSQL_SERVER
</code></pre>
<p>更新成功：<code>mysql-service</code>。具体的，还可以根据 <a target="_blank" rel="noopener" href="https://github.com/omerbsezer/Fast-Kubernetes/blob/main/K8s-Rollout-Rollback.md">https://github.com/omerbsezer/Fast-Kubernetes/blob/main/K8s-Rollout-Rollback.md</a> 中提到的两种策略，指定更新策略。<br><code>Recreate</code> 是全部删除，然后新建（显然服务会有一段时间 Down），而 <code>RollingUpdate</code> 也就是滚动升级，两个版本的 Pod 将同时存在，慢慢将所有 Pod 变为最新版本（关闭一部分旧的，开启一部分新的）。</p>
<h3 id="使用-Kustomize"><a href="#使用-Kustomize" class="headerlink" title="使用 Kustomize"></a>使用 Kustomize</h3><p>项目网址：<a target="_blank" rel="noopener" href="https://github.com/kubernetes-sigs/kustomize">https://github.com/kubernetes-sigs/kustomize</a></p>
<blockquote>
<p>kustomize lets you customize raw, template-free YAML files for multiple purposes, leaving the original YAML untouched and usable as is.</p>
</blockquote>
<p>推荐阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1110336">https://developer.aliyun.com/article/1110336</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liwench/article/details/129849776">https://blog.csdn.net/liwench/article/details/129849776</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/71165168/can-someone-explain-patchesstrategicmerge">https://stackoverflow.com/questions/71165168/can-someone-explain-patchesstrategicmerge</a></li>
</ul>
<p>我们先删除之前测试的残留：</p>
<pre><code class="shell">kubectl delete -f lab1/mysql_configmap.yml
kubectl delete -f lab1/test_deployment.yml
</code></pre>
<p>创建如下的 Kustomization.yml：</p>
<pre><code class="yaml">resources:
  - test_deployment.yml
configMapGenerator:
  - name: mysql-config
    literals:
      - db_server=mysql-service
</code></pre>
<p>查看对应的生成结果（只是打印，没有创建）：</p>
<pre><code class="shell">kubectl kustomize lab1/base
kubectl kustomize lab1/stagging
</code></pre>
<p>应用到 k8s：</p>
<pre><code class="shell">kubectl apply -k lab1/base
</code></pre>
<p>查看生成的 ConfigMap：</p>
<pre><code class="shell">$ kubectl get configmap
NAME                      DATA   AGE
kube-root-ca.crt          1      164m
mysql-config-5bhm7k67gb   1      38s
</code></pre>
<p>进入 Pod，查看环境变量：</p>
<pre><code class="shell">kubectl exec -it test-6fc4d8f9cc-f6zwr -- bin/sh
echo $MYSQL_SERVER
</code></pre>
<p>结果为 mysql-service，和预期一致。</p>
<p>接下来修改为 <code>dummy</code>。</p>
<pre><code class="shell">kubectl apply -k lab1/stagging
</code></pre>
<p>可以发现自动创建了新的 Pod：</p>
<pre><code class="shell">$ kubectl get pods
NAME                    READY   STATUS        RESTARTS   AGE
mysql                   1/1     Running       0          166m
test-6fc4d8f9cc-f6zwr   1/1     Terminating   0          2m13s
test-85d74d7669-d9ft8   1/1     Running       0          26s
</code></pre>
<p>进入 Pod，查看环境变量：</p>
<pre><code class="shell">kubectl exec -it test-85d74d7669-d9ft8 -- bin/sh
echo $MYSQL_SERVER
</code></pre>
<p>输出为 <code>dummy</code>，成功！</p>
<p>注意，原来的 configmap 还是存在的（这种方式比较好，删除总是一个比较危险的行为）。</p>
<pre><code class="shell">$ kubectl get configmap
NAME                      DATA   AGE
kube-root-ca.crt          1      174m
mysql-config-2h6ddfhh59   1      4m48s
mysql-config-5bhm7k67gb   1      6m35s
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Kubernetes/" style="color: #ff7d73">Kubernetes</a>
        </span>
        
    </div>
    <a href="/2023/04/06/k8s-note-2/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/04/06/k8s-note-1/">
        <h2 class="post-title">Kubernetes 笔记（1）—— Informer 与 Controller</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Cloud-Native/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Cloud Native
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1 id="Informer"><a href="#Informer" class="headerlink" title="Informer"></a>Informer</h1><p><img src="/2023/04/06/k8s-note-1/informer.png"></p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><ul>
<li><p>Controller：Informer 的实施载体，可以创建 reflector 及控制 processLoop。processLoop 将DeltaFIFO 队列中的数据 pop 出，首先调用Indexer进行缓存并建立索引，然后分发给 processor 进行处理。</p>
</li>
<li><p>Reflector：Informer 并没有直接访问 api-server，而是通过一个叫 Reflector 的对象进行 api-server 的访问。Reflector 通过 ListAndWatch 监控指定的 kubernetes 资源，当资源发生变化的时候，例如发生了 Added 资源添加等事件，会将其资源对象存放在本地缓存 DeltaFIFO 中。</p>
</li>
<li><p>DeltaFIFO：是一个先进先出的缓存队列，用来存储 Watch API 返回的各种事件，如Added、Updated、Deleted。</p>
</li>
<li><p>Indexer：Indexer 使用一个线程安全的数据存储来存储对象和它们的键值。需要注意的是，Indexer 中的数据与 etcd中 的数据是完全一致的，这样 client-go 需要数据时，无须每次都从 api-server 获取，从而减少了请求过多造成对 api-server 的压力。一句话总结：Indexer 是用于存储+快速查找资源。</p>
</li>
<li><p>Processor：记录了所有的回调函数（即  ResourceEventHandler）的实例，并负责触发回调函数</p>
</li>
</ul>
<h2 id="使用-client-go-自定义-controller"><a href="#使用-client-go-自定义-controller" class="headerlink" title="使用 client-go 自定义 controller"></a>使用 client-go 自定义 controller</h2><p>controller 可以使用 informer 来绑定事件的回调函数，以实现对对象的控制。比如对于 replicaset 而言，监听三种事件，判断 replicaset 实际的 replicas 数量是否符合预期，若不符合预期，则进行相应的扩缩容。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>源自：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/HanFa/learn-k8s/master/lesson3/lesson3_slides.pdf">https://raw.githubusercontent.com/HanFa/learn-k8s/master/lesson3/lesson3_slides.pdf</a></p>
<ul>
<li><p>启动 worker goroutine 之前，先确保 <strong>cache is synced</strong></p>
<ul>
<li><p>Replicaset controller 例子</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L208">https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L208</a></p>
</li>
<li><p>Sample controller 例子</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/HanFa/sample-controller/blob/735d68047545e2fd1fd2bf3c04526f2cf9614e7c/controller.go#L160">https://github.com/HanFa/sample-controller/blob/735d68047545e2fd1fd2bf3c04526f2cf9614e7c/controller.go#L160</a></p>
</li>
</ul>
</li>
<li><p>从cache，或者说informer里拿到的object, 如果要写入，一定要先进行deepcopy，避免 cache 里面的 object被污染。indexer 里面的数据只读的。</p>
<ul>
<li><p>Replicaset controller 例子</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edfb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L712">https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edfb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L712</a></p>
</li>
<li><p>Sample controller 例子<br>  <a target="_blank" rel="noopener" href="https://github.com/kubernetes/sample-controller/blob/f42769d51c5abf1dcc8f887fe1086b14bff6a573/controller.go#L325">https://github.com/kubernetes/sample-controller/blob/f42769d51c5abf1dcc8f887fe1086b14bff6a573/controller.go#L325</a></p>
</li>
</ul>
</li>
<li><p>Informer 的周期性 resync 机制会导致重复冗余的 update 事件，用 ResourceVersion 进行 <strong>early return</strong></p>
<ul>
<li><p>Replicaset controller 例子</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edfb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L420">https://github.com/kubernetes/kubernetes/blob/b7b824bb9e01edfb39411b8c139eab592af0d667/pkg/controller/replicaset/replica_set.go#L420</a></p>
</li>
<li><p>Sample controller 例子</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/kubernetes/sample-controller/blob/f42769d51c5abf1dcc8f887fe1086b14bff6a573/controller.go#L134">https://github.com/kubernetes/sample-controller/blob/f42769d51c5abf1dcc8f887fe1086b14bff6a573/controller.go#L134</a></p>
</li>
</ul>
</li>
<li><p>使用shareinformer来让多个informer共享一个cache；使用NewSharedInformerFactory来新建informer的reference给控制器使用。</p>
<p>  <a target="_blank" rel="noopener" href="https://github.com/HanFa/sample-controller/blob/b3876539afadc37d7b8fc6bd3a2cfd61fb39df4a/main.go#L62">https://github.com/HanFa/sample-controller/blob/b3876539afadc37d7b8fc6bd3a2cfd61fb39df4a/main.go#L62</a></p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Kubernetes/" style="color: #00a596">Kubernetes</a>
        </span>
        
    </div>
    <a href="/2023/04/06/k8s-note-1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2023/03/23/archive-1/">
        <h2 class="post-title">Kubernetes 笔记（0）—— K8s 实践报告</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Cloud-Native/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Cloud Native
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/3/23
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            

	<div class="row">
    <embed src="/2023/03/23/archive-1/k8s实践报告.pdf" width="100%" height="550" type="application/pdf">
	</div>




            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Kubernetes/" style="color: #ffa2c4">Kubernetes</a>
        </span>
        
    </div>
    <a href="/2023/03/23/archive-1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/15/rl/">
        <h2 class="post-title">RL 笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><img src="/2022/12/15/rl/RL_0.png"></p>
<p><img src="/2022/12/15/rl/RL_1.png"></p>
<h2 id="ChatGPT-告诉我们-Trajectory-和-Episode-的区别"><a href="#ChatGPT-告诉我们-Trajectory-和-Episode-的区别" class="headerlink" title="ChatGPT 告诉我们 Trajectory 和 Episode 的区别"></a>ChatGPT 告诉我们 <code>Trajectory</code> 和 <code>Episode</code> 的区别</h2><p><img src="/2022/12/15/rl/RL_15.png"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>强化学习的步骤和基本的机器学习的步骤是类似的：</p>
<ul>
<li><p>第一步：找一个具有未知参数的函数：</p>
<p>  在强化学习中对应于 <code>Actor</code> 的 <code>Policy Network</code>，它通过从 <code>Environment</code> 获取 <code>Observation</code>，并基于此预测要执行什么 <code>Action</code>。<br>  如果这里的 <code>Action</code> 是 <code>stochastic</code> 的，那么就会得到一个 <code>Action</code> 的概率分布，类似于分类问题.</p>
<p>  <img src="/2022/12/15/rl/RL_2.png"></p>
</li>
<li><p>第二步：定义 “loss”：</p>
<p>  我们要使得获取的总体奖励的期望值最大。</p>
<p>  <code>Total reward</code> &#x3D; <code>Return</code></p>
<p>  <img src="/2022/12/15/rl/RL_3.png"></p>
</li>
<li><p>第三步：如何进行优化：</p>
<p>  需要定义一个结束条件，然后让模型经历一个 <code>Trajectory</code>，要使得这个 <code>Trajectory</code> 获得的 <code>Reward</code> 最大。</p>
<p>  <img src="/2022/12/15/rl/RL_4.png"></p>
<p>  <code>Actor</code> 与 <code>Critic</code> 和 <code>GAN</code> 有异曲同工之妙。<code>Actor</code> 对应于 <code>Generator</code>，生成带有随机性的决策；<code>Critic</code> 对应于 <code>Discriminator</code>，判定决策的分数，<br>  并为 <code>Actor</code> 修改策略提供依据和指正。但是不同点在于，<code>GAN</code> 中的 <code>Discriminator</code> 是一个已知的可训练的 model，而强化学习中的 <code>Environment</code> 和 <code>Reward</code> 更像是一个黑盒子，<br>  它们根本不是模型，无法用一般的梯度下降法来解决。</p>
</li>
</ul>
<h2 id="How-to-control-actor"><a href="#How-to-control-actor" class="headerlink" title="How to control actor"></a>How to control actor</h2><p><img src="/2022/12/15/rl/RL_5.png"></p>
<p>其中 $A_n$ 代表一个权重（正数代表我们希望这种动作发生），$e_n$ 代表第 $n$ 次动作产生的“误差”。</p>
<ul>
<li><p>Version 0</p>
<p>  <img src="/2022/12/15/rl/RL_6.png"></p>
<p>  缺点：如果只用一个动作获得的奖励（而不看后续获得的奖励的话），那么 <code>actor</code> 就会偏向于只追求短期利益，<br>  只追求会获得奖励的动作。这显然是错误的，本质上就是一种贪心策略。</p>
</li>
<li><p>Version 1</p>
<p>  <img src="/2022/12/15/rl/RL_7.png"></p>
<p>  改进之后会考虑后续的奖励了，但是在很久之后获得的奖励 $r_N$ 真的可以归功于动作 $a_1$ 吗？显然不能！<br>  我们希望奖励前面有个系数，且这个系数是衰减的，越遥远的奖励和当前执行动作的相关性往往越弱。</p>
</li>
<li><p>Version 2</p>
<p>  <img src="/2022/12/15/rl/RL_8.png"></p>
<p>  引入折扣因子 $\gamma$ 解决上述问题。</p>
</li>
<li><p>Version 3</p>
<p>  奖励是相对的，有些环境只会产生正的反馈，那么如果不对奖励进行修正，那么一些低奖励的动作也会被鼓励。<br>  因此，可以对奖励减去基准 $b$，以对奖励进行标准化。</p>
<p>  <img src="/2022/12/15/rl/RL_9.png"></p>
</li>
<li><p>Version 3.5</p>
<p>  如何更好地确定系数 $A_n$？使用下面讲到的 <code>Critic</code> 的 <code>Value function</code>：</p>
<p>  <img src="/2022/12/15/rl/RL_24.png"></p>
<p>  $V^\theta(s_t)$ 是一个期望值，也就是一个均值（相当于你随机做一串动作获得的奖励差不多就是这个值），作为被减去的 <code>baseline</code>。</p>
<p>  $G^\prime_t$ 则是 <code>actor</code> 获取的实际收益。如果说这个收益大于均值，我们就认为这个动作是好的，是值得鼓励的。</p>
<p>  <img src="/2022/12/15/rl/RL_25.png"></p>
</li>
<li><p>Version 4</p>
<p>  $V^\theta(s_t)$ 是多条路径取平均的结果（因为你在训练 <code>Critic</code> 网络并且让其趋向于期望值），<br>  而 $G^\prime_t$ 则是某一个 <code>sample</code> 的结果，假如说这个 <code>sample</code> 碰巧特别好或者碰巧特别坏，<br>  那么这样计算出来的差值真的能用来评估这个在状态 $s_t$ 下的动作 $a_t$ 的好坏吗？</p>
<p>  举个例子，假如说极端一点， $a_t$ 其实是一个极好的决策，但是后面的决策都做的烂的惨不忍睹，导致 $G^\prime_t \rightarrow -\infty$，这会导致 $A_t &#x3D; G^\prime_t - V^\theta(s_t) \rightarrow -\infty$。<br>  这样就说明我们非常不鼓励 <code>actor</code> 去做 $a_t$，这不就事与愿违了吗？</p>
<p>  所以正确的做法应该是用平均减去平均，以评估 $a_t$ 这一动作的优劣，这也就是大名鼎鼎的 <code>A2C(Advantage Actor-Critic)</code>：</p>
<p>  <img src="/2022/12/15/rl/RL_26.png"></p>
<p>  注意到，我们上面说了 $V^\theta(s_t)$ 会趋向于累计奖励的期望值（乘上折扣因子），也就是说：</p>
<p>  $$<br>  E(G^\prime_t) &#x3D; V^\theta(s_t)\<br>  E(G^\prime_{t+1}) &#x3D; V^\theta(s_{t+1})\<br>  E(r_t) &#x3D; E(G^\prime_{t} - \gamma G^\prime_{t+1})<br>  &#x3D; E(G^\prime_{t}) - \gamma E(G^\prime_{t+1})<br>  &#x3D; V^\theta(s_t) - \gamma V^\theta(s_{t+1})<br>  $$</p>
<p>  故而有：<br>  $$<br>  A_n &#x3D; r_t - E(r_t) &#x3D; r_t + \gamma V^\theta(s_{t+1}) + V^\theta(s_t)<br>  $$</p>
<p>  这里 ppt 上因为之前假设 $\gamma &#x3D; 1$，所以上面省略了 $\gamma$ 这一因子。</p>
</li>
</ul>
<h2 id="Policy-based-Value-based"><a href="#Policy-based-Value-based" class="headerlink" title="Policy-based &amp; Value-based"></a>Policy-based &amp; Value-based</h2><p><img src="/2022/12/15/rl/RL_12.png"></p>
<h2 id="On-policy-vs-Off-policy"><a href="#On-policy-vs-Off-policy" class="headerlink" title="On-policy vs Off-policy"></a>On-policy vs Off-policy</h2><p><img src="/2022/12/15/rl/RL_11.png"></p>
<h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p><img src="/2022/12/15/rl/RL_10.png"></p>
<p>$R_\theta$ 代表了一个 <code>Episode</code> 获得的奖励的总和，$\pi_\theta$ 则代表我们的网络（<code>policy network</code>），其输入是环境的 <code>state</code> ，输出是执行各个动作的概率分布。我们希望 $R_\theta$ 的期望值 $\overline{R_\theta}$ 越大越好。</p>
<p><img src="/2022/12/15/rl/RL_13.png"></p>
<p>$P(\tau|\theta)$ 可以由下面的式子计算，其中 $\tau$ 代表了一个 <code>Trajectory</code>。</p>
<p><img src="/2022/12/15/rl/RL_14.png"></p>
<p>$R_\theta$ 的期望可以通过穷举获得（但是显然不可能，所以可以用尽可能多的次数来近似）</p>
<p><img src="/2022/12/15/rl/RL_16.png"></p>
<p>接下来就可以用 <code>Gradient Discent</code> 来解决这一问题：</p>
<p><img src="/2022/12/15/rl/RL_17.png"></p>
<p>这里认为 $R(\tau)$ 和 $\theta$ 无关，所以即使 $R(\tau)$ 不可微分也无妨。<br>由右边的导数公式就能算出最后的结果。</p>
<p><img src="/2022/12/15/rl/RL_18.png"></p>
<p><img src="/2022/12/15/rl/RL_19.png"></p>
<h2 id="Actor-Critic"><a href="#Actor-Critic" class="headerlink" title="Actor-Critic"></a>Actor-Critic</h2><h3 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h3><p><code>Critic</code> 会有一个 <code>Value function</code> $V^\theta(s)$，它的值代表了 <code>actor</code> 看到状态 $s$ 之后所能获得的打过折扣的累计奖励的期望值。</p>
<p><img src="/2022/12/15/rl/RL_20.png"></p>
<h3 id="如何训练-Value-function"><a href="#如何训练-Value-function" class="headerlink" title="如何训练 Value function"></a>如何训练 <code>Value function</code></h3><ul>
<li><p>蒙特卡罗方法</p>
<p>  让 <code>actor</code> 与环境交互若干次。每次都会获取奖励 $G$，我们期望 $V^\theta(s)$ 的值和 $G$ 越接近越好，可以用 <code>MSE</code> 作为损失函数。</p>
<p>  比如下面的例子，我们就希望 $V^\theta(s_a)$ 与 $G^\prime_a$ 越接近越好。</p>
<p>  <img src="/2022/12/15/rl/RL_21.png"></p>
</li>
<li><p>Temporal-Difference（简称 TD）</p>
<p>  与蒙特卡罗方法不同，<code>TD</code> 是每一步都进行参数更新。</p>
<p>  由：</p>
<p>  $$V^\theta(s_t)&#x3D;\gamma V^\theta(s_{t+1})+r_t$$，</p>
<p>  可知：</p>
<p>  $$V^\theta(s_t)-\gamma V^\theta(s_{t+1})&#x3D;r_t$$</p>
<p>  所以此时我们只要让 $V^\theta(s_t)-\gamma V^\theta(s_{t+1})$ 和 $r_t$ 尽可能接近就行。因为在 $t$ 时刻获得的奖励 $r_t$ 是已知的。</p>
<p>  <img src="/2022/12/15/rl/RL_22.png"></p>
</li>
<li><p>蒙特卡罗方法和 TD 可能会计算出不同的 $V^\theta(s)$</p>
<p>  <img src="/2022/12/15/rl/RL_23.png"></p>
</li>
</ul>
<h3 id="整体训练技巧"><a href="#整体训练技巧" class="headerlink" title="整体训练技巧"></a>整体训练技巧</h3><p>Actor 网络和 Critic 网络可以共享。</p>
<p><img src="/2022/12/15/rl/RL_27.png"></p>
<h2 id="Reward-Shaping"><a href="#Reward-Shaping" class="headerlink" title="Reward Shaping"></a>Reward Shaping</h2><p>在有些环境中，大多数 action 都无法获得或者无法获得较多的 reward，而只有极少数 action 或者只有在最后才能获得较多的 reward（比如围棋）。</p>
<p>我们需要设计额外的 reward 帮助 agent 学习，也就是 <code>reward shaping</code>。</p>
<p><img src="/2022/12/15/rl/RL_28.png"></p>
<p>为 agent 赋予 curiosity，在探索环境中获取 reward，但是必须要避免一直读无意义的新内容以获取 reward。</p>
<h2 id="No-reward-Learning-from-demonstration"><a href="#No-reward-Learning-from-demonstration" class="headerlink" title="No reward: Learning from demonstration"></a>No reward: Learning from demonstration</h2><p>在有些情况下，我们甚至连 reward 都没有，或者说我们难以设计一个好的 reward。<br>这时候，我们可以用一组 export 的 demonstration 来为 agent 提供“动作指导”。</p>
<p><img src="/2022/12/15/rl/RL_29.jpg"></p>
<p>这种方式有点类似于监督学习，但是我们不能只用监督学习的方式来训练 agent。使用监督学习，实际上就是让 agent 学会模仿 export 的动作，本质上是一种 cloning 的行为。<br>但是，我们往往无法知道 export 的 demonstration 里面哪些是不该学习的“个性化”的 action。而且，如果只学习 export 的 demonstration，那么 agent 就会无法学习到一些突发情况的解决方式，<br>因为 export 实在太厉害了，往往都是顺利地解决问题。</p>
<p><img src="/2022/12/15/rl/RL_30.jpg"></p>
<h3 id="Inverse-Reinforcement-Learning"><a href="#Inverse-Reinforcement-Learning" class="headerlink" title="Inverse Reinforcement Learning"></a>Inverse Reinforcement Learning</h3><p>我们可以通过 export 的 demonstration 来学习一个 <code>Reward Function</code>，然后再利用这个 <code>Reward Function</code> 进行普通的强化学习。</p>
<p><img src="/2022/12/15/rl/RL_31.jpg"></p>
<p>我们需要定义一个 reward function，对于老师的行为和学生的行为都会去评估他们的奖励，我们希望老师的奖励应该要大于学生（学生的奖励 - 老师的奖励作为损失），并且对于学生而言，<br>它的目标就是学习获得最大的奖励（基于新的 reward function）。</p>
<p><img src="/2022/12/15/rl/RL_32.jpg"></p>
<p>整体的框架和思想其实和 GAN 有异曲同工之妙。</p>
<p><img src="/2022/12/15/rl/RL_33.jpg"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/AI/" style="color: #00bcd4">AI</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Reinforcement-Learning/" style="color: #00a596">Reinforcement Learning</a>
        </span>
        
    </div>
    <a href="/2022/12/15/rl/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/05/explainable-ai/">
        <h2 class="post-title">Explainable AI 笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h3 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h3><p>用一个灰色色块遮盖图像，最后一行的图像展示了不同位置遮盖之后分类的概率，由此我们可以发现模型学习到了什么重要的特征。</p>
<p><img src="/2022/12/05/explainable-ai/Explainable-AI_0.png"></p>
<p>比如上图中的狗，遮住脸之后模型就无法辨别了，所以模型学习到了狗的面部特征。</p>
<h3 id="Saliency-Map"><a href="#Saliency-Map" class="headerlink" title="Saliency Map"></a>Saliency Map</h3><p>修改某一像素的值 $e$，得到最终输出结果 $x$。计算 $e$ 关于 $x$ 的偏导数，将数值以下方的图像展示。</p>
<p><img src="/2022/12/05/explainable-ai/Explainable-AI_1.png"></p>
<p>一般而言，如果这个偏导数很大，说明这个像素对模型判定结果的影响很大，可以证明这个像素较为重要。 </p>
<p>但是你不能说一个特征很重要，修改对应的像素就一定会产生很大的判定结果的变化。这是因为，以分类问题为例，假如说模型有充分的信心判定一张图片是狗的图片（判断到了很多特征，比如狗腿，狗头），<br>那么你修改其中一个比较重要的特征，可能还是不影响模型判断它是狗。</p>
<p>通过这种方式，你还可以判断你的模型是否真的学习到了正确的特征。下图是一个错误的例子，机器学习到只要判定左下角是否有文字，就可以判定是不是马，<br>因为所有的马的训练集都有左下角的文字。</p>
<p><img src="/2022/12/05/explainable-ai/Explainable-AI_2.png"></p>
<h3 id="SmoothGrad"><a href="#SmoothGrad" class="headerlink" title="SmoothGrad"></a>SmoothGrad</h3><p><code>SmoothGrad</code> 是对 <code>Saliency Map</code> 的一种改进。其做法就是将原图加随机噪声生成多份，再获取对应的多份 <code>Saliency Map</code>，最终取平均得到 <code>SmoothGrad</code>。</p>
<p><img src="/2022/12/05/explainable-ai/Explainable-AI_3.png"></p>
<h3 id="用另一个网络来聆听-可视化一个模型的隐藏层输出"><a href="#用另一个网络来聆听-可视化一个模型的隐藏层输出" class="headerlink" title="用另一个网络来聆听&#x2F;可视化一个模型的隐藏层输出"></a>用另一个网络来聆听&#x2F;可视化一个模型的隐藏层输出</h3><p><img src="/2022/12/05/explainable-ai/Explainable-AI_4.png"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/AI/" style="color: #ff7d73">AI</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Explainable-AI/" style="color: #00bcd4">Explainable AI</a>
        </span>
        
    </div>
    <a href="/2022/12/05/explainable-ai/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/03/diffusion/">
        <h2 class="post-title">Diffusion Model 笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/3
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <ul>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1re4y1m7gb/?spm_id_from=333.999.0.0&vd_source=f7e4c2acec163bdcd3e200e3623cc3e3">简单易懂diffusion模型讲解 - 从前置知识深度生成模型 隐变量 VAE开始</a></p>
<p>  up 主：<a target="_blank" rel="noopener" href="https://space.bilibili.com/10407305">是好梦梦哦</a></p>
<p>  对应的 PPT：<a href="./doc/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82diffusion%E6%A8%A1%E5%9E%8B%E8%AE%B2%E8%A7%A3%20-%20%E4%BB%8E%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%20%E9%9A%90%E5%8F%98%E9%87%8F%20VAE%E5%BC%80%E5%A7%8B.pptx">简单易懂diffusion模型讲解 - 从前置知识深度生成模型 隐变量 VAE开始</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ne411u7J6/?spm_id_from=333.999.0.0&vd_source=f7e4c2acec163bdcd3e200e3623cc3e3">非常详尽的数学推理</a></p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/AI/" style="color: #00bcd4">AI</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Diffusion-Model/" style="color: #00a596">Diffusion Model</a>
        </span>
        
    </div>
    <a href="/2022/12/03/diffusion/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/02/auto-encoder/">
        <h2 class="post-title">Auto Encoder 笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/2
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><img src="/2022/12/02/auto-encoder/ae4.png"></p>
<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>训练一个 <code>Encoder</code> 和 <code>Decoder</code>：</p>
<ul>
<li><code>Encoder</code> 将图像这样高维度的信息压缩为一个低维度的向量（Dimension Reduction）。</li>
<li><code>Decoder</code> 将这个低维度的向量重新复原为原始图像。</li>
</ul>
<p><img src="/2022/12/02/auto-encoder/ae1.png"></p>
<h3 id="为什么这种方法行之有效？"><a href="#为什么这种方法行之有效？" class="headerlink" title="为什么这种方法行之有效？"></a>为什么这种方法行之有效？</h3><p>为什么我们能够将一个高维度的图像信息压缩为一个很低维度的向量？因为对于图像而言，绝大多数都是无意义的噪声，<br>就像你随机生成一个灰度图的二维矩阵，大概率得到的是一堆噪音。而真正有意义的图像其实只占极少的比例。</p>
<p>以 3x3 的图像举例，在这么小的图像里，可能只有两种布局是有意义的，那么 <code>Encoder</code> 完全可以输出一个二维的向量，<br>代表这两种情况。</p>
<p><img src="/2022/12/02/auto-encoder/ae2.png"></p>
<p>也就是说，在图像这样的极高维空间中，真正有意义的图像只占很小的空间，我们可以用压缩的信息（类似于 Word Embedding）将它们尽可能表示出来 。</p>
<h2 id="De-noising-Auto-encoder"><a href="#De-noising-Auto-encoder" class="headerlink" title="De-noising Auto-encoder"></a>De-noising Auto-encoder</h2><p><code>BERT</code> 的预训练也用到了去噪自编码器的思想。</p>
<p><img src="/2022/12/02/auto-encoder/ae3.png"></p>
<h2 id="Feature-Disentangle"><a href="#Feature-Disentangle" class="headerlink" title="Feature Disentangle"></a>Feature Disentangle</h2><p><img src="/2022/12/02/auto-encoder/ae5.png"></p>
<p>Encoder 虽然能够将多种特征，信息提取成一个向量，但是我们无法知道向量中哪个维度对应了什么。<code>Feature Disentangle</code> 就是要去解决这个问题。</p>
<p><img src="/2022/12/02/auto-encoder/ae6.png"></p>
<h3 id="应用：Voice-Conversion"><a href="#应用：Voice-Conversion" class="headerlink" title="应用：Voice Conversion"></a>应用：Voice Conversion</h3><p>既然我们可以用 <code>Feature Disentangle</code> 来了解哪些维度对应了声音的特征，哪些维度对应了声音的内容，<br>那我们就可以选择对应声音的特征的维度进行声音的替换（保持声音内容的维度不变，将声音特征的部分替换成新垣结衣的）。</p>
<p><img src="/2022/12/02/auto-encoder/ae7.png"></p>
<h2 id="Discrete-Latent-Representation"><a href="#Discrete-Latent-Representation" class="headerlink" title="Discrete Latent Representation"></a>Discrete Latent Representation</h2><p><img src="/2022/12/02/auto-encoder/ae8.png"></p>
<h2 id="Text-as-Representation"><a href="#Text-as-Representation" class="headerlink" title="Text as Representation"></a>Text as Representation</h2><p>尝试让 <code>Encoder</code> 生成摘要（既然 <code>Decoder</code> 能够将其还原，说明 <code>Encoder</code> 生成的东西代表了文章的核心和精华内容）。 </p>
<p>和 <code>CycleGAN</code> 一样。如果不使用 <code>Discriminator</code> 会导致这个摘要完全不可读（<code>Encoder</code> 和 <code>Decoder</code> 在加密通话）</p>
<h2 id="Generator-what-VAE-does"><a href="#Generator-what-VAE-does" class="headerlink" title="Generator(what VAE does)"></a>Generator(what VAE does)</h2><p><img src="/2022/12/02/auto-encoder/ae9.png"></p>
<h2 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h2><p><img src="/2022/12/02/auto-encoder/ae10.png"></p>
<h2 id="Anomaly-Detection（异常检测）"><a href="#Anomaly-Detection（异常检测）" class="headerlink" title="Anomaly Detection（异常检测）"></a>Anomaly Detection（异常检测）</h2><p>异常检测是一个 <code>One-class</code> 的分类问题，数据集是极度不对称的：你有大量正常的数据，和极少数不正常的数据，甚至你不知道不正常的数据长什么样，<br>这时候你要怎么训练？这不是一个一般的分类问题，需要用 <code>Auto-encoder</code> 来进行解决。</p>
<p>判断是否能够重构：</p>
<p><img src="/2022/12/02/auto-encoder/ae11.png"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/AI/" style="color: #00a596">AI</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Anto-Encoder/" style="color: #ff7d73">Anto Encoder</a>
        </span>
        
    </div>
    <a href="/2022/12/02/auto-encoder/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/12/01/bert/">
        <h2 class="post-title">BERT 笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/AI/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                AI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/12/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1810.04805v2">https://arxiv.org/abs/1810.04805v2</a></p>
<p><img src="/2022/12/01/bert/BERT0.jpg"></p>
<blockquote>
<p>BERT是2018年10月由Google AI研究院提出的一种预训练模型。BERT的全称是Bidirectional Encoder Representation from Transformers。BERT在机器阅读理解顶级水平测试SQuAD1.1中表现出惊人的成绩: 全部两个衡量指标上全面超越人类，并且在11种不同NLP测试中创出SOTA表现，包括将GLUE基准推高至80.4% (绝对改进7.6%)，MultiNLI准确度达到86.7% (绝对改进5.6%)，成为NLP发展史上的里程碑式的模型成就。</p>
</blockquote>
<p>芝麻街大家族。</p>
<p><img src="/2022/12/01/bert/BERT1.png"></p>
<h2 id="BERT-的结构"><a href="#BERT-的结构" class="headerlink" title="BERT 的结构"></a>BERT 的结构</h2><p>沿用了 <code>Transformer</code> 的 <code>Encoder</code>。</p>
<p><img src="/2022/12/01/bert/BERT14.jpg"></p>
<p><img src="/2022/12/01/bert/BERT15.jpg"></p>
<h2 id="BERT-是怎么学做填空题的？"><a href="#BERT-是怎么学做填空题的？" class="headerlink" title="BERT 是怎么学做填空题的？"></a>BERT 是怎么学做填空题的？</h2><blockquote>
<p>BERT 的作者认为：使用两个方向（从左至右和从右至左）的单向编码器拼接而成的双向编码器，在性能、参数规模和效率等方面都不如直接使用双向编码器强大；这是 BERT 模型使用 Transformer Encoder 结构作为特征提取器，而不拼接使用两个方向的 Transformer Decoder 结构作为特征提取器的原因。</p>
</blockquote>
<blockquote>
<p>这也令 BERT 模型不能像 GPT 模型一样，继续使用标准语言模型的训练模式，因此 BERT 模型重新定义了两种模型训练方法（即：预训练任务）：MLM 和 NSP。BERT用MLM（Masked Language Model，掩码语言模型）方法训练词的语义理解能力，用NSP（Next Sentence Prediction，下句预测）方法训练句子之间的理解能力，从而更好地支持下游任务。</p>
</blockquote>
<h3 id="Masking-Input"><a href="#Masking-Input" class="headerlink" title="Masking Input"></a>Masking Input</h3><p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1810.04805">https://arxiv.org/abs/1810.04805</a></p>
<p>在给 <code>BERT</code> 数据的时候，将若干字替换成一个特殊的 <code>token</code>，或者随机的值。两种方式随机选择一种。</p>
<p><img src="/2022/12/01/bert/BERT3.png"></p>
<p>前面提到过，<code>BERT</code> 即是 <code>Encoder</code>，会输出一个向量的序列。 将这个向量经过一个线性层 + <code>softmax</code> 就可以得到遮住的字的概率分布。<br>我们既然已经知道“台”后面的字是“湾”，也就是说我们有标签，自然就可以用交叉熵作为损失函数训练咯~</p>
<p>这也就是“自己出题，自己回答”。</p>
<h3 id="Next-Sentence-Prediction"><a href="#Next-Sentence-Prediction" class="headerlink" title="Next Sentence Prediction"></a>Next Sentence Prediction</h3><p><code>SEP</code> 区分两个句子。</p>
<p>这边只看 <code>CLS</code> 对应的输出，经过线性变换，做一个二元分类问题（Yes&#x2F;No），即判断两个句子是不是相邻的。</p>
<h2 id="BERT-学到了什么？"><a href="#BERT-学到了什么？" class="headerlink" title="BERT 学到了什么？"></a>BERT 学到了什么？</h2><p>自监督学习。</p>
<p><img src="/2022/12/01/bert/BERT2.jpg"></p>
<p><code>BERT</code> 实际上学到了如何做填空题。</p>
<p><img src="/2022/12/01/bert/BERT5.png"></p>
<p>先预训练，然后在微调以适应不同的任务。就像一个干细胞，可以分化成任何人体细胞。</p>
<p><code>BERT</code> 本身是无监督的（自己出填空题，自己学着做），但是其下游任务（downstream task）可能是监督学习的。比如语句情感分类，利用之前学习填空题 pretrain<br>过的 <code>BERT</code> 模型，将其输出经过另一个网络（这个网络是需要投喂数据集监督学习的），最终输出情感分类。</p>
<p>pretrain 过的 <code>BERT</code> 会比随机参数的好。All you need is <strong>fine-tuning!</strong></p>
<p><img src="/2022/12/01/bert/BERT7.png"></p>
<p>对于词性识别，流程也是类似的。生成的每个向量都通过一个待训练网络，剩下的和上面的例子一样。</p>
<p><img src="/2022/12/01/bert/BERT8.jpg"></p>
<p>判断假设和推断是否矛盾：</p>
<p><img src="/2022/12/01/bert/BERT9.jpg"></p>
<p>输入文章和问题，返回两个整数（答案的起止位置）：</p>
<p><img src="/2022/12/01/bert/BERT10.jpg"></p>
<p>和自注意力机制类似，橙色部分类似于一个 <code>Query</code>，去查询 <code>document</code> 中的每一个 <code>Key</code>，最终经过 <code>softmax</code> 的到最大概率的作为 start。<br>这边 s &#x3D; 2。</p>
<p><img src="/2022/12/01/bert/BERT11.jpg"></p>
<p>还有一个蓝色的向量需要学习，对应于 end。和 start 类似，这边求出 e &#x3D; 3。于是我们得出了答案的范围。</p>
<p><img src="/2022/12/01/bert/BERT12.jpg"></p>
<p>注意橙色和蓝色向量都是要训练的对象。</p>
<h3 id="Training-BERT-is-challenging"><a href="#Training-BERT-is-challenging" class="headerlink" title="Training BERT is challenging"></a>Training BERT is challenging</h3><p>训练 <code>BERT</code> 需要极大的数据量和极强的硬件。</p>
<h3 id="预训练-Seq2Seq"><a href="#预训练-Seq2Seq" class="headerlink" title="预训练 Seq2Seq"></a>预训练 Seq2Seq</h3><p>类似的，也可以预训练 <code>Decoder</code>。将一些句子破坏掉（原始句子作为标签），进行 <code>self-supervise</code></p>
<p><img src="/2022/12/01/bert/BERT13.jpg"></p>
<h2 id="为什么-BERT-能够工作？"><a href="#为什么-BERT-能够工作？" class="headerlink" title="为什么 BERT 能够工作？"></a>为什么 BERT 能够工作？</h2><p><img src="/2022/12/01/bert/BERT18.jpg"></p>
<p>类似于 <code>word2vec</code>，<code>BERT</code> 能够将每个词都对应到一个向量（表征某个词的含义（meaning））。向量两两之间的距离代表了两个词的意思的接近程度。</p>
<p><img src="/2022/12/01/bert/BERT16.jpg"></p>
<p>但是不同的是，<code>BERT</code> 在预训练的时候会学习到上下文信息，同一个字在不同的上下文中，其含义不同，<code>BERT</code> 输出的向量也不同。所以 <code>BERT</code> 输出的<br><code>Embedding</code> 是动态的，会根据上下文的不同产生变化。</p>
<p>以 <code>苹果</code> 为例，“吃苹果”的“苹果”是一种水果，而“苹果手机”的“苹果”则是一个公司品牌名。</p>
<p>通过计算这两个苹果经过 <code>BERT</code> 输出的 <code>Embedding</code> 的 <code>cosine similarity</code>，可以得到下图：</p>
<p><img src="/2022/12/01/bert/BERT17.jpg"></p>
<h2 id="令人震惊的-BERT"><a href="#令人震惊的-BERT" class="headerlink" title="令人震惊的 BERT"></a>令人震惊的 BERT</h2><h3 id="DNA-classification"><a href="#DNA-classification" class="headerlink" title="DNA classification"></a>DNA classification</h3><p>用语言资料预训练的 <code>BERT</code> 甚至可以提升 <code>DNA</code> 分类的准确度！</p>
<p><img src="/2022/12/01/bert/BERT19.jpg"></p>
<p>因为预训练用的是英语，所以这边需要将碱基对对应到一个随机词汇上，然后再对 <code>DNA</code> 分类问题进行 <code>Fine-Tune</code>。即使是这样八竿子打不着的映射，<br>居然也能学出更好的效果——难道 <code>DNA</code> 序列结构和某种语言语法结构有关？ </p>
<p><img src="/2022/12/01/bert/BERT20.jpg"></p>
<h3 id="Multi-lingual-BERT"><a href="#Multi-lingual-BERT" class="headerlink" title="Multi-lingual BERT"></a>Multi-lingual BERT</h3><p>用多种语言的资料训练的 <code>BERT</code> 能够学习到语言之间的联系，在没有学习中文问答资料的情况下，输入中文问题居然也可以达到惊人的准确率。</p>
<p><img src="/2022/12/01/bert/BERT22.jpg"></p>
<p>似乎 <code>BERT</code> 在学到 <code>Rabbit</code> 和 <code>兔</code> 的向量距离很近的同时，也没有忘记语言类型信息。也就是在回答中文问题的时候，它不会将 <code>兔</code> 替换成 <code>Rabbit</code>，<br>而是都用中文来回答。</p>
<p><img src="/2022/12/01/bert/BERT23.jpg"></p>
<p>或许是因为，两个词汇虽然很接近，但是在它们所处的极高维空间内，它们根本不在同一个维度，只是距离相近，仅此而已。</p>
<p>如果将不同语言的所有词汇的 <code>Embedding</code> 求均值，将会发现这些语言在高维空间中散落在不同的区域。假如说你求出 <code>中文</code> 和 <code>English</code> 的这种距离，<br>然后将一个英文 <code>Embedding</code> 加上这个距离，你将会得到中文的 <code>Embedding</code>！</p>
<p><img src="/2022/12/01/bert/BERT24.jpg"></p>
<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p><img src="/GPT2.jpg"></p>
<h2 id="预训练"><a href="#预训练" class="headerlink" title="预训练"></a>预训练</h2><p>结构类似 <code>Transformer</code> 的 <code>Decoder</code>（使用 <code>Masked self-attention</code>）。</p>
<p><img src="/GPT1.jpg"></p>
<p><code>GPT</code> 和 <code>BERT</code> 不一样的地方在于 <code>GPT</code> 是在是太大了，以至于我们难以 <code>Fine-tune</code> 它。 </p>
<h3 id="In-context-learning"><a href="#In-context-learning" class="headerlink" title="In-context learning"></a>In-context learning</h3><p>这里不会去利用梯度下降更新 <code>GPT</code> 的参数。</p>
<h3 id="Few-shot-One-shot-Zero-shot-Learning"><a href="#Few-shot-One-shot-Zero-shot-Learning" class="headerlink" title="Few-shot&#x2F;One-shot&#x2F;Zero-shot Learning"></a>Few-shot&#x2F;One-shot&#x2F;Zero-shot Learning</h3><p>提供任务描述和例子，学会举一反三。</p>
<ul>
<li><p>Few-shot:</p>
<p>  <img src="/GPT3.jpg"></p>
</li>
<li><p>One-shot:</p>
<p>  <img src="/GPT4.jpg"></p>
</li>
<li><p>Zero-shot:</p>
<p>  <img src="/GPT5.jpg"></p>
</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/GPT6.jpg"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/BERT/" style="color: #ffa2c4">BERT</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/Transformer/" style="color: #00bcd4">Transformer</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/NLP/" style="color: #03a9f4">NLP</a>
        </span>
        
    </div>
    <a href="/2022/12/01/bert/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <a class="page-num" href="/page/2/">
        <i class="fa-solid fa-caret-left fa-fw"></i>
    </a>
    <a class="page-num" href="/">1</a>
    <span class="page-omit">...</span>
    
    <span class="current">3</span>
    
    <a class="page-num" href="/page/4">4</a>
    
    
    
    
    <a class="page-num" href="/page/4/">
        <i class="fa-solid fa-caret-right fa-fw"></i>
    </a>
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">Zihong Lin</div>
        <div class="description">
            <p>What I can’t create, I don’t understand.</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 Okabe&#39;s LAB
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Zihong Lin
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
</body>
</html>
